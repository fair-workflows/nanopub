{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to nanopub\u2019s documentation!","text":"<p>The <code>nanopub</code> library provides a high-level, user-friendly python interface for searching, publishing and retracting nanopublications.</p> <p>Nanopublications are a formalized and machine-readable way of communicating the smallest possible units of publishable information. See the What are Nanopublications? page for more information.</p>"},{"location":"#setup","title":"\ud83d\udce6\ufe0f Setup","text":"<p>Install using pip:</p> <pre><code>pip install nanopub\n</code></pre> <p>To publish to the nanopub server you need to setup your profile, this allows the nanopub server to identify you. To check if your profile is properly set, run <code>np profile</code> in your terminal. If it is not set yet, run the following interactive command to setup your profile:</p> <pre><code>np setup\n</code></pre> <p>This will add and store RSA keys to sign your nanopublications, publish a nanopublication with your name and ORCID iD to declare that you are using using these RSA keys, and store your ORCID iD to automatically add as author to the provenance of any nanopublication you will publish using this library.</p>"},{"location":"#quick-start","title":"\u26a1\ufe0f Quick Start","text":""},{"location":"#publishing-nanopublications","title":"Publishing nanopublications","text":"<p>Use <code>load_profile()</code> to load the user profile from <code>$HOME/.nanopub</code>, and <code>use_test_server</code> to point to the test server (remove it to publish to the nanopublication network)</p> <pre><code>import rdflib\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\n# 1. Create the config\nnp_conf = NanopubConf(\n    profile=load_profile(),\n    use_test_server=True,\n    add_prov_generated_time=True,\n    attribute_publication_to_profile=True,\n)\n\n# 2. Construct a desired assertion (a graph of RDF triples) using rdflib\nmy_assertion = rdflib.Graph()\nmy_assertion.add((\n    rdflib.URIRef('www.example.org/timbernerslee'),\n    rdflib.RDF.type,\n    rdflib.FOAF.Person\n))\n\n# 3. Make a Nanopub object with this assertion\nnp = Nanopub(\n    conf=np_conf,\n    assertion=my_assertion\n)\n\n# 4. Publish the Nanopub object\nnp.publish()\nprint(np)\n</code></pre> <p>You can also just sign the nanopub with <code>np.sign()</code>. Upon signing, or publishing, the <code>np</code> object will be automatically updated with the signed RDF and generated trusty URI.</p>"},{"location":"#searching-for-nanopublications","title":"Searching for nanopublications","text":"<pre><code>from nanopub import NanopubClient\n\n# Create the client\nclient = NanopubClient()\n\n# Search for all nanopublications containing the text 'fair'\nresults = client.find_nanopubs_with_text('fair')\nfor result in results:\n    print(result)\n</code></pre>"},{"location":"#fetching-nanopublications-and-inspecting-them","title":"Fetching nanopublications and inspecting them","text":"<pre><code>from nanopub import NanopubClient\n\n# Create the client\nclient = NanopubClient()\n\n# Fetch the nanopublication at the specified URI\nnp = client.fetch('http://purl.org/np/RApJG4fwj0szOMBMiYGmYvd5MCtRle6VbwkMJUb1SxxDM')\nprint(np)\n\n# Iterate through all triples in the assertion graph\nfor s, p, o in np.assertion:\n    print(s, p, o)\n</code></pre>"},{"location":"getting-started/development/","title":"Development","text":""},{"location":"getting-started/development/#install-for-development","title":"\ud83d\udce5 Install for development","text":"<p>Clone the repository and go in the project folder:</p> <pre><code>git clone https://github.com/fair-workflows/nanopub\ncd nanopub\n</code></pre> <p>To install the project for development you can either use <code>venv</code> to create a virtual environment yourself, or use <code>hatch</code> to automatically handle virtual environments for you.</p> venvhatch <p>Create the virtual environment in the project folder :</p> <pre><code>python3 -m venv .venv\n</code></pre> <p>Activate the virtual environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>Install all dependencies required for development:</p> <pre><code>pip install -e \".[dev,doc,test]\"\n</code></pre> <p>Install <code>pre-commit</code> to enable automated formatting and linting of the code at each commit:</p> <pre><code>pre-commit install\n</code></pre> <p>Install Hatch, this will automatically handle virtual environments and make sure all dependencies are installed when you run a script in the project:</p> <pre><code>pip install hatch\n</code></pre> Optionally you can improve <code>hatch</code> terminal completion <p>See the official documentation for more details. For ZSH you can run these commands:</p> <pre><code>_HATCH_COMPLETE=zsh_source hatch &gt; ~/.hatch-complete.zsh\necho \". ~/.hatch-complete.zsh\" &gt;&gt; ~/.zshrc\n</code></pre>"},{"location":"getting-started/development/#development-workflow","title":"\ud83e\uddd1\u200d\ud83d\udcbb Development workflow","text":"venvhatch <p>Try to sign a nanopublication with the code defined in <code>scripts/dev.py</code> to test your changes:</p> <pre><code>./scripts/dev.sh\n</code></pre> <p>The code will be automatically formatted when you commit your changes using <code>pre-commit</code>. But you can also run the script to format the code yourself:</p> <pre><code>./scripts/format.sh\n</code></pre> <p>Check the code for errors, and if it is in accordance with the PEP8 style guide, by running <code>flake8</code> and <code>mypy</code>:</p> <pre><code>./scripts/lint.sh\n</code></pre> <p>Try to sign a nanopublication with the code defined in <code>scripts/dev.py</code> to test your changes:</p> <pre><code>hatch run dev\n</code></pre> <p>The code will be automatically formatted when you commit your changes using <code>pre-commit</code>. But you can also run the script to format the code yourself:</p> <pre><code>hatch run format\n</code></pre> <p>Check the code for errors, and if it is in accordance with the PEP8 style guide, by running <code>flake8</code> and <code>mypy</code>:</p> <pre><code>hatch run lint\n</code></pre>"},{"location":"getting-started/development/#run-the-tests","title":"\u2705 Run the tests","text":"<p>Tests are automatically run by a GitHub Actions workflow when new code is pushed to the GitHub repository.</p> <p>The tests use the <code>nanopub-java</code> tool for validating the signing process implemented in python produces similar nanopublications. This is automatically installed by the library, just make sure <code>java</code> is available where you run the tests.</p> venvhatch <p>Run the tests locally:</p> <pre><code>./scripts/test.sh\n</code></pre> <p>You can also run only a specific test:</p> <pre><code>./scripts/test.sh tests/test_nanopub.py::test_nanopub_sign_uri\n</code></pre> <p>Run the tests locally:</p> <pre><code>hatch run test\n</code></pre> <p>You can also run only a specific test:</p> <pre><code>hatch run test tests/test_nanopub.py::test_nanopub_sign_uri\n</code></pre>"},{"location":"getting-started/development/#generate-docs","title":"\ud83d\udcd6 Generate docs","text":"<p>The documentation (this website) is automatically generated from the markdown files in the <code>docs</code> folder and python docstring comments, and published by a GitHub Actions workflow.</p> <p>Serve the docs on http://localhost:8008</p> venvhatch <pre><code>./scripts/docs.sh\n</code></pre> <pre><code>hatch run docs\n</code></pre>"},{"location":"getting-started/development/#publish-a-new-release","title":"\ud83c\udff7\ufe0f Publish a new release","text":"<ol> <li>Increment the <code>__version__</code> in <code>nanopub/_version.py</code></li> <li>Push to GitHub</li> <li>Create a new release on GitHub</li> <li>A GitHub Action workflow will automatically publish the new version to PyPI</li> </ol>"},{"location":"getting-started/setup/","title":"Setup instructions","text":""},{"location":"getting-started/setup/#install-the-nanopub-library","title":"\ud83d\udce5\ufe0f Install the nanopub library","text":"<p>Install using pip: <pre><code>pip install nanopub\n</code></pre></p>"},{"location":"getting-started/setup/#setup-for-users-new-to-python","title":"\ud83d\udc0d Setup for users new to python","text":"<p>We recommend using anaconda to install python and manage python dependencies</p>"},{"location":"getting-started/setup/#setup-your-profile","title":"\ud83d\udc64 Setup your profile","text":"<p>To publish to the nanopub server you need to setup your profile (note that you can use fetch and search functionality without a profile). This allows the nanopub server to identify you.</p> <p>To check if your profile is properly set, run the following command in your terminal:</p> <pre><code>np profile\n</code></pre> <p>To setup your profile, run the following interactive command:</p> <pre><code>np setup\n</code></pre> <p>This will setup the following:</p>"},{"location":"getting-started/setup/#stored-profile","title":"Stored profile","text":"<p>A local version of the profile will be stored in the nanopub user config dir (by default <code>HOMEDIR/.nanopub/profile.yml</code>)</p>"},{"location":"getting-started/setup/#rsa-keys","title":"RSA keys","text":"<p>It will add and store RSA keys to sign your nanopublications. By default they are stored under <code>HOMEDIR/.nanopub/id_rsa</code> and <code>HOMEDIR/.nanopub/id_rsa.pub</code>.</p>"},{"location":"getting-started/setup/#orcid-id","title":"ORCID iD","text":"<p>This includes your ORCID iD (i.e. https://orcid.org/0000-0000-0000-0000).</p> <p>If you don\u2019t have an ORCID iD yet, you need to register. We use the ORCID iD to automatically add as author to the provenance of any nanopublication you will publish using this library.</p>"},{"location":"getting-started/setup/#introductory-nanopublication","title":"Introductory nanopublication","text":"<p>We encourage you to make use of <code>np setup</code>\u2019s option to publish your profile to the nanopub servers. This links your ORCID iD to your RSA key, thereby making all your publications linkable to you. Here is an example introductory nanopublicaiton. The link to this nanopublication is also stored in your profile.</p>"},{"location":"getting-started/setup/#check-your-profile","title":"\u2611\ufe0f Check your profile","text":"<p>You can check the profile currently used by default by running this command in your terminal:</p> <pre><code>np profile\n</code></pre>"},{"location":"getting-started/test-server/","title":"The nanopub test server","text":"<p>Throughout this documentation we make use of the nanopub test server by setting <code>use_test_server=True</code> when instantiating <code>NanopubConf</code> or <code>NanopubClient</code>: <pre><code>from nanopub import NanopubClient, NanopubConf\n\nclient = NanopubClient(use_test_server=True)\nnp_conf = NanopubConf(use_test_server=True)\n</code></pre> This will search and fetch from, and publish to the nanopub test server.</p> <p>When learning about nanopub using the testserver is a good idea, because: * You are free to experiment with publishing without polluting the production server. * You can draft a publication and know exactly what it will look like on the nanopub server without polluting the production server. * When searching (and to a lesser extent fetching) you are not putting an unnecessary load on the production server.</p>"},{"location":"getting-started/test-server/#test-purl-uris-do-not-point-to-the-test-server","title":"Test purl URIs do not point to the test server","text":"<p>There is one caveat when using the test server that can be confusing: The purl URI (for example: http://purl.org/np/RA71u9tYPd7ZQifE_6hXjqVim6pkweuvjoi-8ehvLvzg8) points to the nanopub production server resulting in a 404 page not found error.</p> <p>A manual workaround is: 1. Open http://purl.org/np/RA71u9tYPd7ZQifE_6hXjqVim6pkweuvjoi-8ehvLvzg8  in your browser 2. Notice that the URL changed to http://server.nanopubs.lod.labs.vu.nl/RA71u9tYPd7ZQifE_6hXjqVim6pkweuvjoi-8ehvLvzg8. 3. Replace \u2018server\u2019 with \u2018test-server\u2019: https://np.test.knowledgepixels.com/RA71u9tYPd7ZQifE_6hXjqVim6pkweuvjoi-8ehvLvzg8.</p> <p>NB: <code>NanopubClient.fetch()</code> does this for you if <code>use_test_server=True</code>.</p>"},{"location":"getting-started/use-the-cli/","title":"Use the command line interface","text":"<p>Once installed, you can use the <code>nanopub</code> library through the <code>np</code> command line interface to sign and publish Nanopublication.</p>"},{"location":"getting-started/use-the-cli/#check-the-current-user-profile","title":"\ud83d\udc64 Check the current user profile","text":"<pre><code>np profile\n</code></pre>"},{"location":"getting-started/use-the-cli/#set-your-user-profile","title":"\u270d\ufe0f Set your user profile","text":"<p>See the setup instructions page for more details about setting up your profile.</p> <pre><code>np setup\n</code></pre>"},{"location":"getting-started/use-the-cli/#sign-nanopubs","title":"\u2712\ufe0f Sign nanopubs","text":"<p>Sign a nanopublication from a file, this will generate the signed nanopub in a new file <code>signed.nanopub.trig</code> alongside the original:</p> <pre><code>np sign nanopub.trig\n</code></pre>"},{"location":"getting-started/use-the-cli/#publish-nanopubs","title":"\ud83d\udcec\ufe0f Publish nanopubs","text":"<p>Publish a nanopublication from a signed file:</p> <pre><code>np publish signed.nanopub.trig\n</code></pre> <p>Or directly publish a nanopublication from an unsigned file:</p> <pre><code>np publish nanopub.trig\n</code></pre> <p>You can also publish to the test server:</p> <pre><code>np publish nanopub.trig --test\n</code></pre>"},{"location":"getting-started/use-the-cli/#check-signed-nanopubs","title":"\u2611\ufe0f Check signed nanopubs","text":"<p>Check if a signed nanopublication is valid:</p> <pre><code>np check signed.nanopub.trig\n</code></pre>"},{"location":"getting-started/use-the-cli/#i-get-help","title":"\u2139\ufe0f Get help","text":"<p>Display the help for the different commands with the <code>--help</code> flag.</p> <pre><code>np --help\nnp sign --help\n</code></pre>"},{"location":"getting-started/what-are-nanopubs/","title":"What are nanopublications?","text":"<p>Nanopublications are a formalized and machine-readable way of communicating the smallest possible units of publishable information. This could be, for example, the outcome of a scientific study or a claim made by a particular scientist.</p> <p>Nanopublications are searchable, citable, and contain authorship and attribution information. The aim is to encourage individual scientific results to be released in a traceable and interoperable format. As such, nanopublications are an effective FAIR means of communicating scientific claims and results.</p> <p>Read more about nanopublications at nanopub.org.</p>"},{"location":"getting-started/what-are-nanopubs/#different-elements-of-a-nanopublication","title":"Different elements of a nanopublication","text":"<p>From nanopub.org documentation (2020/12/02)</p> <p></p> <p>As can be seen in this image, a nanopublication has three basic elements:</p> <ol> <li>Assertion: The assertion is the main content of a nanopublication in the form of an small atomic unit of information</li> <li>Provenance: This part describes how the assertion above came to be. This can include the scientific methods that were used to generate the assertion, for example a reference to the kind of study that was performed and its parameters.</li> <li>Publication Info:  This part contains metadata about the nanopublication as a whole, such as when and by whom it was created and the license terms for its reuse.</li> </ol>"},{"location":"publishing/profile/","title":"Set the user profile","text":"<p>Prerequisite for publishing</p> <p>Before you can sign and publish you should setup your profile, check if it is properly set by running <code>np profile</code> in your terminal.</p>"},{"location":"publishing/profile/#use-the-default-user-profile","title":"\ud83d\udc64 Use the default user profile","text":"<p>If you have setup a profile on your machine following the setup instructions, you can easily load the default profile (defined in <code>$HOME/.nanopub/profile.yml</code>):</p> <pre><code>from nanopub import load_profile\n\np = load_profile()\n</code></pre>"},{"location":"publishing/profile/#define-the-user-profile","title":"\u270d\ufe0f Define the user profile","text":"<p>Otherwise, if you wish to have flexibility when defining the user profile, there are multiple options:</p>"},{"location":"publishing/profile/#load-a-profile-file","title":"Load a profile file","text":"<p>Provide a specific path to a <code>profile.yml</code> file when using the <code>load_profile()</code> function:</p> <pre><code>from nanopub import load_profile\n\np = load_profile(Path('/path/to/profile.yml'))\n</code></pre>"},{"location":"publishing/profile/#provide-the-keys-filepaths","title":"Provide the keys filepaths","text":"<p>If you need to switch between multiple keys it can be convenient to be able to define the profile directly in your code, you can do so with the <code>Profile</code> class:</p> <pre><code>from pathlib import Path\nfrom nanopub import Profile\n\np1 = Profile(\n    name='Your Name',\n    orcid_id='https://orcid.org/0000-0000-0000-0000',\n    private_key=Path.home() / \"id_rsa\",\n    public_key=Path.home() / \"id_rsa.pub\"\n)\n</code></pre>"},{"location":"publishing/profile/#provide-the-keys-as-strings","title":"Provide the keys as strings","text":"<p>If you need to switch between multiple keys you can also provide the private and public keys as string, without needing to store them in files:</p> <pre><code>from nanopub import Profile\n\np = Profile(\n    name='Your Name',\n    orcid_id='https://orcid.org/0000-0000-0000-0000',\n    private_key=\"YOUR_PRIVATE_KEY\",\n    public_key=\"YOUR_PUBLIC_KEY\"\n)\n</code></pre>"},{"location":"publishing/profile/#generate-new-keys-for-your-nanopub-profile","title":"Generate new keys for your nanopub profile","text":"<p>If you do not provide private and public keys a new key pair will be automatically generated. You can then store it where you want.</p> <pre><code>from nanopub import Profile\n\np = Profile(\n    name='Your Name',\n    orcid_id='https://orcid.org/0000-0000-0000-0000',\n)\n# By default the profile and keys will be stored in $HOME/.nanopub\np.store()\n</code></pre>"},{"location":"publishing/publish-nanopublications/","title":"Publishing nanopublications","text":"<p>The <code>nanopub</code> library provides an intuitive API that makes publishing nanopublications much easier. The rationale is that you often do not want to worry about the details of composing the RDF that is often the same in each nanopublication. Instead you should focus on the content of your nanopublication: the assertion.</p>"},{"location":"publishing/publish-nanopublications/#a-simple-recipe-to-publish-rdf-triples","title":"\ud83d\udcdc A simple recipe to publish RDF triples","text":"<p>You can use <code>Nanopub</code> objects to easily publish nanopublications with your assertion (think of the assertion as the content of your nanopublication).</p> <p>This is a 3-step recipe that works for most cases:</p> <ol> <li>Create a <code>NanopubConf</code></li> <li>Construct a desired assertion using <code>rdflib</code>.</li> <li>Make a <code>Nanopub</code> object from the assertion.</li> <li>Publish the <code>Nanopub</code> object using <code>.publish()</code>.</li> </ol> <p>Here is an example: <pre><code>import rdflib\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\n# 1. Create the config (we use use_test_server=True to point to the test server)\nnp_conf = NanopubConf(\n    profile=load_profile(),\n    use_test_server=True,\n    add_prov_generated_time=True,\n    attribute_publication_to_profile=True,\n)\n\n# 2. Construct a desired assertion (a graph of RDF triples) using RDFLib\nmy_assertion = rdflib.Graph()\nmy_assertion.add((\n    rdflib.URIRef('www.example.org/timbernerslee'),\n    rdflib.RDF.type,\n    rdflib.FOAF.Person\n))\n\n# 3. Make a Nanopub object with this assertion\nnp = Nanopub(\n    conf=np_conf,\n    assertion=my_assertion\n)\n\n# 4. Publish the Publication object.\nnp.publish()\nprint(np)\n</code></pre></p> <p>View an example of resulting nanopublication here.</p> <p>You can also just sign the nanopub with <code>np.sign()</code>. Upon signing, or publishing, the <code>np</code> object will be automatically updated with the signed RDF and generated trusty URI.</p> <p>This is the resulting assertion part of the nanopublication:</p> <pre><code>@prefix sub: &lt;http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ#&gt; .\n\nsub:assertion {\n    &lt;https://www.example.org/timbernerslee&gt; a &lt;http://xmlns.com/foaf/0.1/Person&gt; .\n}\n</code></pre> <p>The library automatically adds relevant RDF triples for the provenance part of the nanopublication: <pre><code>@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .\n@prefix sub: &lt;http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ#&gt; .\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .\n\nsub:provenance {\n    sub:assertion prov:generatedAtTime \"2020-12-01T10:44:32.367084\"^^xsd:dateTime .\n}\n</code></pre> as well as for the publication info part of the nanopublication: <pre><code>@prefix npx: &lt;http://purl.org/nanopub/x/&gt; .\n@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .\n@prefix sub: &lt;http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ#&gt; .\n@prefix this: &lt;http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ&gt; .\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .\n\nsub:pubinfo {\n    sub:sig npx:hasAlgorithm \"RSA\" ;\n        npx:hasPublicKey \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCmso7vmRO/Cp4Pt0RkJJkV5qfc1WFYU/jMtkdxxb5+lfIVXNV97XQnM1Tj4fkb/W6jkP6fHl8mj8Q7hl7VgUnQ6I+B7cMGpxW9Z8Br+JNx8DPMMt08VCH5+JMENPRKl91r7rF/YPWCAgL9eqXSixCNMNAj5RBmMTQoPuRkpgmt1wIDAQAB\" ;\n        npx:hasSignature \"aPZMJ3Md6X1PHYvXJiNoRUni9+1oS9faCfiPRRCrj4K/uZPN0J/znjxGuCUxoZRJ4b4RfSxmHFGRKfCFusJX+7Y3xuxYx4GYHzYhBciK7T5pO02V4w6sdwHLKd5E+Wcl0PTr2t3lEjq6yzY98wEXlZLAbaRDBJvzpg5xORifQDw=\" ;\n        npx:hasSignatureTarget this: .\n\n    this: prov:generatedAtTime \"2020-12-01T10:44:32.367084\"^^xsd:dateTime ;\n        prov:wasAttributedTo &lt;https://orcid.org/0000-0000-0000-0000&gt; .\n}\n</code></pre></p>"},{"location":"publishing/publish-nanopublications/#publish-from-a-file","title":"\ud83d\udcc2 Publish from a file","text":"<p>You can also easily sign and publish a Nanopublication from a file.</p> <pre><code>from rdflib import ConjunctiveGraph\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\n# 1. Create the config\nnp_conf = NanopubConf(profile=load_profile(), use_test_server=True)\n\n# 2. Load the file in a RDFLib graph\ng = ConjunctiveGraph()\ng.parse(\"nanopub.trig\")\n\n# 3. Make a Nanopublication object with this assertion\nnp = Nanopub(conf=np_conf, rdf=g)\n\n# 4. Publish the Publication object.\nnp.publish()\nprint(np)\n</code></pre>"},{"location":"publishing/publish-nanopublications/#display-more-logs","title":"\ud83d\udda8\ufe0f Display more logs","text":"<p>You can change the log level of your logger to display more logs from the nanopub library, which can be help when debugging.</p> <pre><code>import rdflib\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\n# Instantiate the logger\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nconsole_handler = logging.StreamHandler()\nformatter = logging.Formatter(\n    \"%(asctime)s %(levelname)s: [%(module)s:%(funcName)s] %(message)s\"\n)\nconsole_handler.setFormatter(formatter)\nlogger.addHandler(console_handler)\n\n# Usual workflow to publish nanopubs\nnp_conf = NanopubConf(\n    profile=load_profile(),\n    use_test_server=True,\n    add_prov_generated_time=True,\n    attribute_publication_to_profile=True,\n)\n\nmy_assertion = rdflib.Graph()\nmy_assertion.add((\n    rdflib.URIRef('www.example.org/timbernerslee'),\n    rdflib.RDF.type,\n    rdflib.FOAF.Person\n))\n\nnp = Nanopub(\n    conf=np_conf,\n    assertion=my_assertion\n)\nnp.publish()\nprint(np)\n</code></pre>"},{"location":"publishing/publish-nanopublications/#configure-the-nanopubs","title":"\u2699\ufe0f Configure the nanopubs","text":"<p>The  <code>NanopubConf</code> class is used to create a reusable configuration for the nanopublications you create and publish. It enables you to define:</p> <ul> <li>which triples will be automatically added to the <code>provenance</code> and <code>pubinfo</code> graphs</li> <li>which user <code>Profile</code> to use</li> <li>to which server nanopubs will be published</li> </ul> <pre><code>import rdflib\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\nnp_conf = NanopubConf(\n    profile=load_profile(),\n\n    # Define which server must be used (will be production by default)\n    use_test_server=True,\n    use_server=\"http://test-server.nanopubs.lod.labs.vu.nl\",\n\n    # Add at which date and time the nanopub was generated:\n    add_prov_generated_time=True,\n    add_pubinfo_generated_time=True,\n\n    # Attribute the assertion or publication to your profile ORCID:\n    attribute_assertion_to_profile=True,\n    attribute_publication_to_profile= True,\n\n    # Specify that the nanopub assertion is derived from another URI\n    # (such as an existing nanopub):\n    derived_from = \"http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ\"\n)\n\n# Usual workflow to build publish a nanopub\nmy_assertion = rdflib.Graph()\nmy_assertion.add((\n    rdflib.URIRef('www.example.org/timbernerslee'),\n    rdflib.RDF.type,\n    rdflib.FOAF.Person\n))\nnp = Nanopub(\n    conf=np_conf,\n    assertion=my_assertion\n)\nnp.publish()\nprint(np)\n</code></pre> <p>You can also directly provide an ORCID to attribute the publication to, instead of using the user profile:</p> <pre><code>from nanopub import NanopubConf, load_profile\n\ncreator_orcid = \"https://orcid.org/0000-0000-0000-0000\"\n\nnp_conf = NanopubConf(\n    profile=load_profile(),\n    use_test_server=True,\n    use_server=\"http://test-server.nanopubs.lod.labs.vu.nl\",\n    add_prov_generated_time=True,\n    add_pubinfo_generated_time=True,\n    # Directly provide the ORCID:\n    assertion_attributed_to = creator_orcid,\n    publication_attributed_to = creator_orcid,\n)\n</code></pre>"},{"location":"publishing/retraction/","title":"Retracting a nanopublication","text":"<p>A nanopublication is persistent, you can never edit nor delete it. You can however retract a nanopublication. This is done by publishing a new nanopublication that states that you retract the original publication. You can use <code>NanopubClient.retract()</code>: <pre><code>from nanopub import NanopubConf, NanopubRetract\n\nnp_conf = NanopubConf(profile=load_profile(), use_test_server=True)\n\nnp = NanopubRetract(\n    'http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ',\n    np_conf,\n)\nnp.publish()\n</code></pre> View the full retraction nanopublication here.</p> <p>The assertion states that the researcher (denoted by the ORCID iD from your profile) retracts the provided nanopublication: <pre><code>@prefix npx: &lt;http://purl.org/nanopub/x/&gt; .\n@prefix sub: &lt;http://purl.org/np/RAv75Xhhz5jv--Nnu9RDqIGy2xHr74REGC4vtOSxrwX4c#&gt; .\n\nsub:assertion {\n    &lt;https://orcid.org/0000-0000-0000-0000&gt; npx:retracts &lt;http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ&gt; .\n}\n</code></pre> By default nanopublications that have a valid retraction do not show up in search results. A valid retraction is a retraction that is signed with the same public key as the nanopublication that it retracts.</p>"},{"location":"publishing/retraction/#retracting-a-nanopublication-that-is-not-yours","title":"Retracting a nanopublication that is not yours","text":"<p>By default we do not retract nanopublications that are not yours (i.e. signed with another public key). If you try to do this it will trigger an AssertionError.</p> <p>We can use <code>force=True</code> to override this behavior: <pre><code>np = NanopubRetract(\n    'http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ',\n    np_conf,\n    force=True\n)\n</code></pre></p>"},{"location":"publishing/retraction/#find-retractions-of-a-given-nanopublication","title":"Find retractions of a given nanopublication","text":"<p>You can find out whether a given publication is retracted and what the nanopublications are that retract it using <code>NanopubClient.find_retractions_of</code>: <pre><code>from nanopub import NanopubClient\nclient = NanopubClient(use_test_server=True)\n# This URI has 1 retraction:\nclient.find_retractions_of('http://purl.org/np/RAirauh-vy5f7UJEMTm08C5bh5pnWD-abb-qk3fPYWCzc')\n['http://purl.org/np/RADjlGIB8Vqt7NbG1kqzw-4aIV_k7nyIRirMhPKEYVSlc']\n# This URI has no retractions\nclient.find_retractions_of('http://purl.org/np/RAeMfoa6I05zoUmK6sRypCIy3wIpTgS8gkum7vdfOamn8')\n[]\n</code></pre></p>"},{"location":"publishing/setting-subgraphs/","title":"Setting publication info and provenance","text":"<p>Here we show how you can control the publication info and provenance parts of the nanopublication.</p>"},{"location":"publishing/setting-subgraphs/#specifying-where-the-nanopublication-is-derived-from","title":"Specifying where the nanopublication is derived from","text":"<p>You can specify that the nanopub\u2019s assertion is derived from another URI (such as an existing nanopublication): <pre><code>from rdflib import URIRef, Graph, BNode, RDF, FOAF\nfrom nanopub import Nanopub\n\nmy_assertion = Graph()\nmy_assertion.add((BNode('timbernserslee'), RDF.type, FOAF.Person))\n\nnp = Nanopub(\n    assertion=my_assertion,\n    conf=NanopubConf(\n        add_prov_generated_time=True,\n        add_pubinfo_generated_time=True,\n        attribute_publication_to_profile=True,\n        derived_from=URIRef('http://www.example.org/another-nanopublication'),\n    )\n)\n</code></pre> Note that <code>derived_from</code> may also be passed a list of URIs.</p> <p>The provenance part of the publication will denote: <pre><code>@prefix sub: &lt;http://purl.org/nanopub/temp/mynanopub#&gt; .\n@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .\n\n:provenance {\n    sub:assertion prov:wasDerivedFrom &lt;http://www.example.org/another-nanopublication&gt; .\n}\n</code></pre></p>"},{"location":"publishing/setting-subgraphs/#attributing-the-assertion-to-someone","title":"Attributing the assertion to someone","text":"<p>You can attribute the assertion to someone by specifying the <code>assertion_attributed_to</code> argument: <pre><code>from rdflib import URIRef, Graph, BNode, RDF, FOAF\nfrom nanopub import Nanopub\n\nmy_assertion = Graph()\nmy_assertion.add((BNode('timbernserslee'), RDF.type, FOAF.Person))\n\nnp = Nanopub(\n    assertion=my_assertion,\n    conf=NanopubConf(\n        add_prov_generated_time=True,\n        add_pubinfo_generated_time=True,\n        attribute_publication_to_profile=True,\n        assertion_attributed_to=URIRef('https://orcid.org/0000-0000-0000-0000'),\n    )\n)\n</code></pre></p> <p>The provenance part of the publication will denote: <pre><code>@prefix : &lt;http://purl.org/nanopub/temp/mynanopub#&gt; .\n@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .\n\n:provenance {\n    :assertion prov:wasAttributedTo &lt;https://orcid.org/0000-0000-0000-0000&gt; .\n}\n</code></pre> Note: Often the assertion should be attributed to yourself.</p> <p>Instead of passing your ORCID iD to <code>assertion_attributed_to</code>, you can easily tell nanopub to attribute the assertion to the ORCID iD in your profile by setting <code>attribute_assertion_to_profile=True</code>.</p>"},{"location":"publishing/setting-subgraphs/#specifying-custom-provenance-triples","title":"Specifying custom provenance triples","text":"<p>You can add your own triples to the provenance graph of the nanopublication by passing them in an <code>rdflib.Graph</code> object to the <code>provenance_rdf</code> argument: <pre><code>import rdflib\nfrom nanopub import namespaces, Nanopub\n\nmy_assertion = rdflib.Graph()\nmy_assertion.add((rdflib.term.BNode('timbernserslee'), rdflib.RDF.type, rdflib.FOAF.Person))\n\nprovenance_rdf = rdflib.Graph()\nprovenance_rdf = provenance_rdf.add((\n    BNode('timbernserslee'),\n    namespaces.PROV.actedOnBehalfOf,\n    BNode('markzuckerberg')\n))\n\nnp = Nanopub(\n    assertion=my_assertion,\n    provenance_rdf=provenance_rdf,\n    conf=NanopubConf(\n        add_prov_generated_time=True,\n        add_pubinfo_generated_time=True,\n        attribute_publication_to_profile=True,\n    )\n)\n</code></pre></p>"},{"location":"publishing/setting-subgraphs/#specifying-custom-publication-info-triples","title":"Specifying custom publication info triples","text":"<p>You can add your own triples to the publication info graph of the nanopublication by passing them in an <code>rdflib.Graph</code> object to the <code>pubinfo_rdf</code> argument: <pre><code>from rdflib import Graph, BNode, RDF, FOAF\nfrom nanopub import namespaces, Nanopub\n\nmy_assertion = Graph()\nmy_assertion.add((BNode('timbernserslee'), RDF.type, FOAF.Person))\n\npubinfo_rdf = rdflib.Graph()\npubinfo_rdf = pubinfo_rdf.add((\n    BNode('activity'),\n    RDF.type,\n    namespaces.PROV.Activity\n))\n\nnp = Nanopub(\n    assertion=my_assertion,\n    pubinfo=pubinfo_rdf,\n    conf=NanopubConf(\n        add_prov_generated_time=True,\n        add_pubinfo_generated_time=True,\n        attribute_publication_to_profile=True,\n    )\n)\n</code></pre></p>"},{"location":"publishing/templates/","title":"Using nanopublications templates","text":"<p>The nanopub library provides a few objects to easily publish specific types of nanopublications, such as claims, retraction, nanopub indexes, or ORCID introductions.</p> <p>You can also easily create your own template by inheriting from the <code>Nanopub</code> class.</p>"},{"location":"publishing/templates/#nanopub-index","title":"\ud83d\uddc2\ufe0f Nanopub index","text":"<p>To publish an index of nanopublications. Note that a nanopub cannot contain more than 1200 triples. So to publish large index with more than 1200 elements we need to split it and publish multiple nanopublications: the different nanopub index that composes this index, and a top level index that points to all the nanopub indexes.</p> <p>For this we will use the <code>create_nanopub_index()</code> function instead of directly instantiating a <code>NanopubIndex</code></p> <pre><code>from nanopub import create_nanopub_index, NanopubConf\n\nnp_conf = NanopubConf(profile=load_profile(), use_test_server=True)\n\nnp_list = create_nanopub_index(\n    conf=np_conf,\n    np_list=[\n        \"https://purl.org/np/RAD28Nl4h_mFH92bsHUrtqoU4C6DCYy_BRTvpimjVFgJo\",\n        \"https://purl.org/np/RAEhbEJ1tdhPqM6gNPScX9vIY1ZtUzOz7woeJNzB3sh3E\",\n    ],\n    title=\"My nanopub index\",\n    description=\"This is my nanopub index\",\n    creation_time=\"2020-09-21T00:00:00\",\n    creators=[\"https://orcid.org/0000-0000-0000-0000\"],\n    see_also=\"https://github.com/fair-workflows/nanopub\",\n)\nfor np in np_list:\n    np.publish()\n    print(np)\n</code></pre>"},{"location":"publishing/templates/#orcid-introduction","title":"\ud83d\udc64 ORCID introduction","text":"<p>To publish a nanopublication introducing a keypair for an ORCID.</p> <pre><code>from nanopub import NanopubConf, NanopubIntroduction\n\nnp_conf = NanopubConf(profile=load_profile(), use_test_server=True)\n\nnp = NanopubIntroduction(\n    conf=np_conf,\n    host=None,\n)\nnp.publish()\n</code></pre>"},{"location":"publishing/templates/#update-a-published-nanopub","title":"\ud83d\udcdd Update a published nanopub","text":"<p>To update a nanopub content, provide the URI to the nanopub to update, and the new assertion graph. You can also provide the pubinfo, provenance and complete RDF (like for the <code>Nanopub</code> object).</p> <pre><code>from nanopub import NanopubConf, NanopubUpdate\n\nnp_conf = NanopubConf(profile=load_profile())\n\nassertion = Graph()\nassertion.add((\n    BNode('test'), namespaces.HYCL.claims, Literal('This is the updated nanopublication assertion')\n))\nnp = NanopubUpdate(\n    uri=\"http://purl.org/np/RAfk_zBYDerxd6ipfv8fAcQHEzgZcVylMTEkiLlMzsgwQ\",\n    conf=np_conf,\n    assertion=assertion,\n)\nnp.sign()\n</code></pre>"},{"location":"publishing/templates/#claim","title":"\ud83d\udcac Claim","text":"<p>Publish a simple HYCL claim:</p> <pre><code>from nanopub import NanopubConf, NanopubClaim\n\nnp_conf = NanopubConf(profile=load_profile(), use_test_server=True)\n\nnp = NanopubClaim(\n    claim='All cats are grey',\n    conf=np_conf,\n)\nnp.publish()\n</code></pre>"},{"location":"publishing/templates/#create-your-own-template","title":"\u270d\ufe0f Create your own template","text":"<p>You can create your own template by inheriting from the <code>Nanopub</code> class. It allows you to define classes to assist your users with publishing specific sets of triples.</p> <p>Here is the <code>NanopubClaim</code> class explained:</p> <pre><code>from rdflib import RDF, RDFS, Literal, URIRef\n\nfrom nanopub.config import NanopubConf\nfrom nanopub.namespaces import HYCL\nfrom nanopub.nanopub import Nanopub\n\nclass NanopubClaim(Nanopub):\n\n    def __init__(\n        self,\n        # Define the args the users should provide\n        claim: str,\n        conf: NanopubConf,\n    ) -&gt; None:\n        # Enforce a specific nanopub conf\n        conf.add_prov_generated_time = True\n        conf.add_pubinfo_generated_time = True\n        conf.attribute_publication_to_profile = True\n        super().__init__(\n            conf=config,\n        )\n\n        # Build the nanopub assertion from the args\n        this_statement = self._namespace.claim\n        self.assertion.add((this_statement, RDF.type, HYCL.Statement))\n        self.assertion.add((this_statement, RDFS.label, Literal(claim)))\n\n        orcid_id_uri = URIRef(self.profile.orcid_id)\n        self.provenance.add((orcid_id_uri, HYCL.claims, this_statement))\n</code></pre>"},{"location":"publishing/using-publication-namespace/","title":"Using the nanopublication\u2019s namespace","text":"<p>In a nanopublication you often want to refer to a concept that is not defined somewhere on the WWW. In that case it makes sense to make use of the namespace of the nanopublication itself, see for example this assertion that uses <code>nanopub-uri#timbernerslee</code> to refer to the concept Tim Berners Lee. <pre><code>@prefix sub: &lt;http://purl.org/np/RA_j6TPcnoQJ_XkISjugTgaRsFGLhpbZCC3mE7fXs0REI#&gt; .\n\nsub:assertion {\n    sub:timbernerslee a &lt;http://xmlns.com/foaf/0.1/Person&gt; .\n}\n</code></pre></p>"},{"location":"publishing/using-publication-namespace/#using-blank-nodes","title":"Using blank nodes","text":"<p>But how do you make use of the nanopublication\u2019s namespace if you do not have access to the published nanopublication URI yet? We solve that by making use of blank nodes.</p> <p>Upon publication, any blank nodes in the rdf graph are replaced with the nanopub\u2019s URI, with the blank node name as a fragment. For example, if the blank node is called \u2018timbernerslee\u2019, that would result in a URI composed of the nanopub\u2019s (base) URI, followed by #timbernslee. We can thus use blank nodes to refer to new concepts, making use of the namespace of the to-be-published URI.</p> <p>An example:</p> <pre><code>from rdflib import Graph, BNode, RDF, FOAF\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\nmy_assertion = Graph()\n\n# We want to introduce a new concept in our publication: Tim Berners Lee\ntim = BNode('timbernerslee')\n\n# We assert that he is a person\nmy_assertion.add((tim, RDF.type, FOAF.Person) )\n\n# Define the config for your nanopubs\nnp_conf = NanopubConf(\n    profile=load_profile(),\n    add_prov_generated_time=True,\n    add_pubinfo_generated_time=True,\n    attribute_publication_to_profile=True,\n)\n# And create a nanopub object for this assertion\nnp = Nanopub(\n    assertion=my_assertion,\n    conf=np_conf\n)\n\n# Let's publish this to the test server\nnp.publish()\nprint(np)\n</code></pre> <p>View the full nanopublication here.</p> <p>As you can see in the assertion, the \u2018timbernerslee\u2019 blank node is replaced with a uri in the nanopublication\u2019s namespace: <pre><code>@prefix sub: &lt;http://purl.org/np/RAdaZsPRcY5usXFKwSBfz9g-HOu-Bo1XmmhQc4g7uESgU#&gt; .\n\nsub:assertion {\n    sub:timbernerslee a &lt;http://xmlns.com/foaf/0.1/Person&gt; .\n}\n</code></pre></p>"},{"location":"publishing/using-publication-namespace/#introducing-a-concept","title":"Introducing a concept","text":"<p>You can optionally specify that the Publication introduces a particular concept using blank nodes.</p> <p>The pubinfo graph will note that this nanopub npx:introduces the concept. The concept should be a blank node (rdflib.term.BNode), and is converted to a URI derived from the nanopub\u2019s URI with a fragment (#) made from the blank node\u2019s name.</p> <p>An example:</p> <pre><code>import rdflib\nfrom nanopub import Nanopub, NanopubConf, load_profile\n\nmy_assertion = rdflib.Graph()\n\n# We want to introduce a new concept in our publication: Tim Berners Lee\ntim = rdflib.BNode('timbernerslee')\n\n# We assert that he is a person\nmy_assertion.add((tim, rdflib.RDF.type, rdflib.FOAF.Person) )\n\n# And create a nanopub introducing this new concept\nnp = Nanopub(\n    assertion=my_assertion,\n    introduces_concept=tim,\n    conf=NanopubConf(\n        profile=load_profile(),\n        add_prov_generated_time=True,\n        add_pubinfo_generated_time=True,\n        attribute_publication_to_profile=True,\n    )\n)\n\n# Let's publish this to the test server\nnp.publish()\nprint(np)\n# Published to http://purl.org/np/RAq9gFEgxlOyG9SSDZ5DmBbyGet2z6pkrdWXIVYa6U6qI\n# Published concept to http://purl.org/np/RAq9gFEgxlOyG9SSDZ5DmBbyGet2z6pkrdWXIVYa6U6qI#timbernerslee\n</code></pre> <p>View the full nanopublication here.</p> <p>The publication info of the nanopublication denotes that this nanopublication introduces the \u2018timbernerslee\u2019 concept: <pre><code>@prefix npx: &lt;http://purl.org/nanopub/x/&gt; .\n@prefix sub: &lt;http://purl.org/np/RAq9gFEgxlOyG9SSDZ5DmBbyGet2z6pkrdWXIVYa6U6qI#&gt; .\n@prefix this: &lt;http://purl.org/np/RAq9gFEgxlOyG9SSDZ5DmBbyGet2z6pkrdWXIVYa6U6qI&gt; .\n\nsub:pubinfo {\n   this: npx:introduces sub:timbernerslee .\n}\n</code></pre></p>"},{"location":"reference/client/","title":"NanopubClient","text":"<p>Provides utility functions for searching published nanopublications.</p> <p>Parameters:</p> Name Type Description Default <code>use_test_server</code> <code>bool</code> <p>Toggle using the test nanopub server.</p> <code>False</code> <code>use_server</code> <code>str</code> <p>Provide the URL of a nanopub server to use</p> <code>NANOPUB_SERVER_LIST[0]</code> Source code in <code>nanopub/client.py</code> <pre><code>class NanopubClient:\n    \"\"\"\n    Provides utility functions for searching published nanopublications.\n\n    Args:\n        use_test_server (bool): Toggle using the test nanopub server.\n        use_server (str): Provide the URL of a nanopub server to use\n    \"\"\"\n\n    def __init__(\n        self,\n        use_test_server=False,\n        use_server=NANOPUB_SERVER_LIST[0],\n    ):\n        self.use_test_server = use_test_server\n        if use_test_server:\n            self.grlc_urls = [NANOPUB_TEST_GRLC_URL]\n            self.use_server = NANOPUB_TEST_SERVER\n        else:\n            self.grlc_urls = NANOPUB_GRLC_URLS\n            self.use_server = use_server\n            if use_server not in NANOPUB_SERVER_LIST:\n                log.warn(f\"{use_server} is not in our list of nanopub servers. {', '.join(NANOPUB_SERVER_LIST)}\\nMake sure you are using an existing Nanopub server.\")\n\n\n    def find_nanopubs_with_text(\n        self, text: str, pubkey: str = None, filter_retracted: bool = True\n    ):\n        \"\"\"Text search.\n\n        Search the nanopub servers for any nanopubs matching the\n        given search text.\n\n        Args:\n            text (str): The text to search on\n            pubkey (str): Public key that the matching nanopubs should be signed with\n            filter_retracted (bool): Toggle filtering for publications that are\n                retracted. Default is True, returning only publications that are not retracted.\n\n        Yields:\n            results (dict): dicts depicting matching nanopublications.\n                Each dict holds: 'np': the nanopublication uri,\n                'date': date of creation of the nanopublication,\n                'description': A description of the nanopublication (if found in RDF).\n\n        \"\"\"\n        if len(text) == 0:\n            return []\n        endpoint = \"find_signed_nanopubs_with_text\"\n        params = {\"text\": text, \"graphpred\": \"\", \"month\": \"\", \"day\": \"\", \"year\": \"\"}\n        if pubkey:\n            params[\"pubkey\"] = pubkey\n        if filter_retracted:\n            endpoint = \"find_valid_signed_nanopubs_with_text\"\n        return self._search(endpoint=endpoint, params=params)\n\n\n    def find_nanopubs_with_pattern(\n        self,\n        subj: str = None,\n        pred: str = None,\n        obj: str = None,\n        filter_retracted: bool = True,\n        pubkey: str = None,\n    ):\n        \"\"\"Pattern search.\n\n        Search the nanopub servers for any nanopubs matching the given RDF pattern. You can leave\n        parts of the triple to match anything by not specifying subj, pred, or obj arguments.\n\n        Args:\n            subj (str): URI of the subject that you want to match triples on.\n            pred (str): URI of the predicate that you want to match triples on.\n            obj (str): URI of the object that you want to match triples on.\n            pubkey (str): Public key that the matching nanopubs should be signed with\n            filter_retracted (bool): Toggle filtering for publications that are\n                retracted. Default is True, returning only publications that are not retracted.\n\n        Yields:\n            results (dict): dicts depicting matching nanopublications.\n                Each dict holds: 'np': the nanopublication uri,\n                'date': date of creation of the nanopublication,\n                'description': A description of the nanopublication (if found in RDF).\n\n        \"\"\"\n        params = {}\n        endpoint = \"find_signed_nanopubs_with_pattern\"\n        if subj:\n            params[\"subj\"] = subj\n        if pred:\n            params[\"pred\"] = pred\n        if obj:\n            params[\"obj\"] = obj\n        if pubkey:\n            params[\"pubkey\"] = pubkey\n        if filter_retracted:\n            endpoint = \"find_valid_signed_nanopubs_with_pattern\"\n\n        yield from self._search(endpoint=endpoint, params=params)\n\n\n    def find_things(\n        self,\n        type: str,\n        searchterm: str = \" \",\n        pubkey: str = None,\n        filter_retracted: bool = True,\n    ):\n        \"\"\"Search things (experimental).\n\n        Search for any nanopublications that introduce a concept of the given type, that contain\n        text with the given search term.\n\n        Args:\n            type (str): A URI denoting the type of the introduced concept\n            searchterm (str): The term that you want to search on\n            pubkey (str): Public key that the matching nanopubs should be signed with\n            filter_retracted (bool): Toggle filtering for publications that are\n                retracted. Default is True, returning only publications that are not retracted.\n\n        Yields:\n            results (dict): dicts depicting matching nanopublications.\n                Each dict holds: 'np': the nanopublication uri,\n                'date': date of creation of the nanopublication,\n                'description': A description of the nanopublication (if found in RDF).\n\n        \"\"\"\n        if searchterm == \"\":\n            raise ValueError(f\"Searchterm can not be an empty string: {searchterm}\")\n        endpoint = \"find_signed_things\"\n        params = dict()\n        params[\"type\"] = type\n        params[\"searchterm\"] = searchterm\n        if pubkey:\n            params[\"pubkey\"] = pubkey\n        if filter_retracted:\n            endpoint = \"find_valid_signed_things\"\n\n        yield from self._search(endpoint=endpoint, params=params)\n\n\n    def find_retractions_of(\n        self, source: Union[str, Nanopub], valid_only=True\n    ) -&gt; List[str]:\n        \"\"\"Find retractions of given URI\n\n        Find all nanopublications that retract a certain nanopublication.\n\n        Args:\n            source (str or nanopub.Publication): URI or Nanopub object to find retractions for\n            valid_only (bool): Toggle returning only valid retractions, i.e. retractions that are\n                signed with the same public key as the publication they retract. Default is True.\n\n        Returns:\n            List of uris that retract the given URI\n        \"\"\"\n\n        if isinstance(source, Nanopub):\n            if source.is_test_publication and not self.use_test_server:\n                warnings.warn(\n                    \"You are trying to find retractions on the production server, \"\n                    \"whereas this publication lives on the test server\"\n                )\n            elif not source.is_test_publication and self.use_test_server:\n                warnings.warn(\n                    \"You are trying to find retractions on the test server, \"\n                    \"whereas this publication lives on the production server\"\n                )\n            uri = source.source_uri\n        else:\n            uri = source\n\n        if valid_only:\n            source_publication = Nanopub(\n                source_uri=uri,\n                conf=NanopubConf(use_test_server=self.use_test_server)\n            )\n            public_key = source_publication.signed_with_public_key\n            if public_key is None:\n                raise ValueError(\"The source publication is not signed with a public key\")\n        else:\n            public_key = None\n\n        results = self.find_nanopubs_with_pattern(\n            pred=namespaces.NPX.retracts,\n            obj=rdflib.URIRef(uri),\n            pubkey=public_key,\n            filter_retracted=False,\n        )\n        return [result[\"np\"] for result in results]\n\n\n    @staticmethod\n    def _query_grlc(params: dict, endpoint: str, grlc_url: str) -&gt; requests.Response:\n        \"\"\"Query a specific nanopub server grlc endpoint.\"\"\"\n        headers = {\"Accept\": \"application/json\"}\n        url = grlc_url + endpoint\n        return requests.get(url, params=params, headers=headers)\n\n\n    def _query_grlc_try_servers(\n        self, params: dict, endpoint: str\n    ) -&gt; Tuple[requests.Response, str]:\n        \"\"\"Query the nanopub server grlc endpoint.\n\n        Query a nanopub grlc server endpoint (for example: find_text). Try several of the nanopub\n        garlic servers.\n\n        Returns:\n            tuple of: r: request response, grlc_url: url of the grlc server used.\n        \"\"\"\n        r = None\n        random.shuffle(self.grlc_urls)  # To balance load across servers\n        for grlc_url in self.grlc_urls:\n            r = self._query_grlc(params, endpoint, grlc_url)\n            if r.status_code == 502:  # Server is likely down\n                warnings.warn(\n                    f\"Could not get response from {grlc_url}, trying other servers\"\n                )\n            else:\n                r.raise_for_status()  # For non-502 errors we don't want to try other servers\n                return r, grlc_url\n        resp = \"\"\n        if r:\n            resp = f\" Last response: {r.status_code}:{r.reason}\"\n        raise requests.HTTPError(\n            f\"Could not get response from any of the nanopub grlc \"\n            f\"endpoints.{resp}\"\n        )\n\n\n    def _search(self, endpoint: str, params: dict):\n        \"\"\"\n        General nanopub server search method. User should use e.g. find_nanopubs_with_text,\n        find_things etc.\n\n        Args:\n            endpoint: garlic endpoint to query, for example: find_things\n            params: dictionary with parameters for get request\n\n        Raises:\n            JSONDecodeError: in case response can't be serialized as JSON, this can happen due to a\n                virtuoso error.\n        \"\"\"\n        has_results = True\n        page_number = 1\n        grlc_url = None\n        while has_results:\n            params[\"page\"] = page_number\n            # First try different servers\n            if grlc_url is None:\n                r, grlc_url = self._query_grlc_try_servers(params, endpoint)\n            # If we have found a grlc server we should use that for further queries (so\n            # pagination works properly)\n            else:\n                r = self._query_grlc(params, endpoint, grlc_url)\n                r.raise_for_status()\n\n            # Check if JSON was actually returned. HTML can be returned instead\n            # if e.g. virtuoso errors on the backend (due to spaces in the search\n            # string, for example).\n            try:\n                results = r.json()\n            except ValueError as e:\n                # Try to give a more understandable error to user when the response\n                # is not JSON...\n                raise ValueError(\n                    \"The server returned HTML instead of the requested JSON. \"\n                    \"This is usually caused by the triple store (e.g. virtuoso) \"\n                    \"throwing an error for the given search query.\"\n                ) from e\n\n            bindings = results[\"results\"][\"bindings\"]\n            if not bindings:\n                has_results = False\n            page_number += page_number\n            for result in bindings:\n                yield self._parse_search_result(result)\n\n\n    @staticmethod\n    def _parse_search_result(result: dict):\n        \"\"\"\n        Parse a nanopub search result (i.e. referring to one matching nanopublication).\n        Rename 'v' to 'description', select only date, np, label and description fields\n        and unnest them.\n        \"\"\"\n        parsed = dict()\n        parsed[\"np\"] = result[\"np\"][\"value\"]\n\n        if \"v\" in result:\n            parsed[\"description\"] = result[\"v\"][\"value\"]\n        elif \"description\" in result:\n            parsed[\"description\"] = result[\"description\"][\"value\"]\n        else:\n            parsed[\"description\"] = \"\"\n        if \"label\" in result:\n            parsed[\"label\"] = result[\"label\"][\"value\"]\n        parsed[\"date\"] = result[\"date\"][\"value\"]\n        return parsed\n</code></pre>"},{"location":"reference/client/#nanopub.NanopubClient.find_nanopubs_with_pattern","title":"<code>find_nanopubs_with_pattern(subj=None, pred=None, obj=None, filter_retracted=True, pubkey=None)</code>","text":"<p>Pattern search.</p> <p>Search the nanopub servers for any nanopubs matching the given RDF pattern. You can leave parts of the triple to match anything by not specifying subj, pred, or obj arguments.</p> <p>Parameters:</p> Name Type Description Default <code>subj</code> <code>str</code> <p>URI of the subject that you want to match triples on.</p> <code>None</code> <code>pred</code> <code>str</code> <p>URI of the predicate that you want to match triples on.</p> <code>None</code> <code>obj</code> <code>str</code> <p>URI of the object that you want to match triples on.</p> <code>None</code> <code>pubkey</code> <code>str</code> <p>Public key that the matching nanopubs should be signed with</p> <code>None</code> <code>filter_retracted</code> <code>bool</code> <p>Toggle filtering for publications that are retracted. Default is True, returning only publications that are not retracted.</p> <code>True</code> <p>Yields:</p> Name Type Description <code>results</code> <code>dict</code> <p>dicts depicting matching nanopublications. Each dict holds: \u2018np\u2019: the nanopublication uri, \u2018date\u2019: date of creation of the nanopublication, \u2018description\u2019: A description of the nanopublication (if found in RDF).</p> Source code in <code>nanopub/client.py</code> <pre><code>def find_nanopubs_with_pattern(\n    self,\n    subj: str = None,\n    pred: str = None,\n    obj: str = None,\n    filter_retracted: bool = True,\n    pubkey: str = None,\n):\n    \"\"\"Pattern search.\n\n    Search the nanopub servers for any nanopubs matching the given RDF pattern. You can leave\n    parts of the triple to match anything by not specifying subj, pred, or obj arguments.\n\n    Args:\n        subj (str): URI of the subject that you want to match triples on.\n        pred (str): URI of the predicate that you want to match triples on.\n        obj (str): URI of the object that you want to match triples on.\n        pubkey (str): Public key that the matching nanopubs should be signed with\n        filter_retracted (bool): Toggle filtering for publications that are\n            retracted. Default is True, returning only publications that are not retracted.\n\n    Yields:\n        results (dict): dicts depicting matching nanopublications.\n            Each dict holds: 'np': the nanopublication uri,\n            'date': date of creation of the nanopublication,\n            'description': A description of the nanopublication (if found in RDF).\n\n    \"\"\"\n    params = {}\n    endpoint = \"find_signed_nanopubs_with_pattern\"\n    if subj:\n        params[\"subj\"] = subj\n    if pred:\n        params[\"pred\"] = pred\n    if obj:\n        params[\"obj\"] = obj\n    if pubkey:\n        params[\"pubkey\"] = pubkey\n    if filter_retracted:\n        endpoint = \"find_valid_signed_nanopubs_with_pattern\"\n\n    yield from self._search(endpoint=endpoint, params=params)\n</code></pre>"},{"location":"reference/client/#nanopub.NanopubClient.find_nanopubs_with_text","title":"<code>find_nanopubs_with_text(text, pubkey=None, filter_retracted=True)</code>","text":"<p>Text search.</p> <p>Search the nanopub servers for any nanopubs matching the given search text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to search on</p> required <code>pubkey</code> <code>str</code> <p>Public key that the matching nanopubs should be signed with</p> <code>None</code> <code>filter_retracted</code> <code>bool</code> <p>Toggle filtering for publications that are retracted. Default is True, returning only publications that are not retracted.</p> <code>True</code> <p>Yields:</p> Name Type Description <code>results</code> <code>dict</code> <p>dicts depicting matching nanopublications. Each dict holds: \u2018np\u2019: the nanopublication uri, \u2018date\u2019: date of creation of the nanopublication, \u2018description\u2019: A description of the nanopublication (if found in RDF).</p> Source code in <code>nanopub/client.py</code> <pre><code>def find_nanopubs_with_text(\n    self, text: str, pubkey: str = None, filter_retracted: bool = True\n):\n    \"\"\"Text search.\n\n    Search the nanopub servers for any nanopubs matching the\n    given search text.\n\n    Args:\n        text (str): The text to search on\n        pubkey (str): Public key that the matching nanopubs should be signed with\n        filter_retracted (bool): Toggle filtering for publications that are\n            retracted. Default is True, returning only publications that are not retracted.\n\n    Yields:\n        results (dict): dicts depicting matching nanopublications.\n            Each dict holds: 'np': the nanopublication uri,\n            'date': date of creation of the nanopublication,\n            'description': A description of the nanopublication (if found in RDF).\n\n    \"\"\"\n    if len(text) == 0:\n        return []\n    endpoint = \"find_signed_nanopubs_with_text\"\n    params = {\"text\": text, \"graphpred\": \"\", \"month\": \"\", \"day\": \"\", \"year\": \"\"}\n    if pubkey:\n        params[\"pubkey\"] = pubkey\n    if filter_retracted:\n        endpoint = \"find_valid_signed_nanopubs_with_text\"\n    return self._search(endpoint=endpoint, params=params)\n</code></pre>"},{"location":"reference/client/#nanopub.NanopubClient.find_retractions_of","title":"<code>find_retractions_of(source, valid_only=True)</code>","text":"<p>Find retractions of given URI</p> <p>Find all nanopublications that retract a certain nanopublication.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str or Publication</code> <p>URI or Nanopub object to find retractions for</p> required <code>valid_only</code> <code>bool</code> <p>Toggle returning only valid retractions, i.e. retractions that are signed with the same public key as the publication they retract. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of uris that retract the given URI</p> Source code in <code>nanopub/client.py</code> <pre><code>def find_retractions_of(\n    self, source: Union[str, Nanopub], valid_only=True\n) -&gt; List[str]:\n    \"\"\"Find retractions of given URI\n\n    Find all nanopublications that retract a certain nanopublication.\n\n    Args:\n        source (str or nanopub.Publication): URI or Nanopub object to find retractions for\n        valid_only (bool): Toggle returning only valid retractions, i.e. retractions that are\n            signed with the same public key as the publication they retract. Default is True.\n\n    Returns:\n        List of uris that retract the given URI\n    \"\"\"\n\n    if isinstance(source, Nanopub):\n        if source.is_test_publication and not self.use_test_server:\n            warnings.warn(\n                \"You are trying to find retractions on the production server, \"\n                \"whereas this publication lives on the test server\"\n            )\n        elif not source.is_test_publication and self.use_test_server:\n            warnings.warn(\n                \"You are trying to find retractions on the test server, \"\n                \"whereas this publication lives on the production server\"\n            )\n        uri = source.source_uri\n    else:\n        uri = source\n\n    if valid_only:\n        source_publication = Nanopub(\n            source_uri=uri,\n            conf=NanopubConf(use_test_server=self.use_test_server)\n        )\n        public_key = source_publication.signed_with_public_key\n        if public_key is None:\n            raise ValueError(\"The source publication is not signed with a public key\")\n    else:\n        public_key = None\n\n    results = self.find_nanopubs_with_pattern(\n        pred=namespaces.NPX.retracts,\n        obj=rdflib.URIRef(uri),\n        pubkey=public_key,\n        filter_retracted=False,\n    )\n    return [result[\"np\"] for result in results]\n</code></pre>"},{"location":"reference/client/#nanopub.NanopubClient.find_things","title":"<code>find_things(type, searchterm=' ', pubkey=None, filter_retracted=True)</code>","text":"<p>Search things (experimental).</p> <p>Search for any nanopublications that introduce a concept of the given type, that contain text with the given search term.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>A URI denoting the type of the introduced concept</p> required <code>searchterm</code> <code>str</code> <p>The term that you want to search on</p> <code>' '</code> <code>pubkey</code> <code>str</code> <p>Public key that the matching nanopubs should be signed with</p> <code>None</code> <code>filter_retracted</code> <code>bool</code> <p>Toggle filtering for publications that are retracted. Default is True, returning only publications that are not retracted.</p> <code>True</code> <p>Yields:</p> Name Type Description <code>results</code> <code>dict</code> <p>dicts depicting matching nanopublications. Each dict holds: \u2018np\u2019: the nanopublication uri, \u2018date\u2019: date of creation of the nanopublication, \u2018description\u2019: A description of the nanopublication (if found in RDF).</p> Source code in <code>nanopub/client.py</code> <pre><code>def find_things(\n    self,\n    type: str,\n    searchterm: str = \" \",\n    pubkey: str = None,\n    filter_retracted: bool = True,\n):\n    \"\"\"Search things (experimental).\n\n    Search for any nanopublications that introduce a concept of the given type, that contain\n    text with the given search term.\n\n    Args:\n        type (str): A URI denoting the type of the introduced concept\n        searchterm (str): The term that you want to search on\n        pubkey (str): Public key that the matching nanopubs should be signed with\n        filter_retracted (bool): Toggle filtering for publications that are\n            retracted. Default is True, returning only publications that are not retracted.\n\n    Yields:\n        results (dict): dicts depicting matching nanopublications.\n            Each dict holds: 'np': the nanopublication uri,\n            'date': date of creation of the nanopublication,\n            'description': A description of the nanopublication (if found in RDF).\n\n    \"\"\"\n    if searchterm == \"\":\n        raise ValueError(f\"Searchterm can not be an empty string: {searchterm}\")\n    endpoint = \"find_signed_things\"\n    params = dict()\n    params[\"type\"] = type\n    params[\"searchterm\"] = searchterm\n    if pubkey:\n        params[\"pubkey\"] = pubkey\n    if filter_retracted:\n        endpoint = \"find_valid_signed_things\"\n\n    yield from self._search(endpoint=endpoint, params=params)\n</code></pre>"},{"location":"reference/config/","title":"NanopubConf","text":"<p>Represents the configuration for nanopubs.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[Profile]</code> <p>Profile of the user publishing the nanopub</p> <code>None</code> <code>use_test_server</code> <code>bool</code> <p>A boolean to automatically use the test server</p> <code>False</code> <code>use_server</code> <code>str</code> <p>The URL of the server that will be used to publish the nanopub</p> <code>NANOPUB_SERVER_LIST[0]</code> <code>add_prov_generated_time</code> <code>bool</code> <p>add generated time to provenance</p> <code>False</code> <code>add_pubinfo_generated_time</code> <code>bool</code> <p>add generated time to pubinfo</p> <code>False</code> <code>attribute_assertion_to_profile</code> <code>bool</code> <p>bool</p> <code>False</code> <code>attribute_publication_to_profile</code> <code>bool</code> <p>bool</p> <code>False</code> <code>assertion_attributed_to</code> <code>Optional[str]</code> <p>Optional str</p> <code>None</code> <code>publication_attributed_to</code> <code>Optional[str]</code> <p>Optional str</p> <code>None</code> <code>derived_from</code> <code>Optional[str]</code> <p>Optional str</p> <code>None</code> Source code in <code>nanopub/nanopub_conf.py</code> <pre><code>@dataclass\nclass NanopubConf:\n    \"\"\"Represents the configuration for nanopubs.\n\n    Args:\n        profile: Profile of the user publishing the nanopub\n        use_test_server: A boolean to automatically use the test server\n        use_server: The URL of the server that will be used to publish the nanopub\n        add_prov_generated_time: add generated time to provenance\n        add_pubinfo_generated_time: add generated time to pubinfo\n        attribute_assertion_to_profile: bool\n        attribute_publication_to_profile: bool\n        assertion_attributed_to: Optional str\n        publication_attributed_to: Optional str\n        derived_from: Optional str\n    \"\"\"\n\n    profile: Optional[Profile] = None\n\n    use_test_server: bool = False\n    use_server: str = NANOPUB_SERVER_LIST[0]\n\n    add_prov_generated_time: bool = False\n    add_pubinfo_generated_time: bool = False\n\n    attribute_assertion_to_profile: bool = False\n    attribute_publication_to_profile: bool = False\n\n    assertion_attributed_to: Optional[str] = None\n    publication_attributed_to: Optional[str] = None\n\n    derived_from: Optional[str] = None\n\n\n    dict = asdict\n</code></pre>"},{"location":"reference/namespaces/","title":"Namespaces","text":"<p>This module holds handy namespaces that are often used in nanopublications.</p>"},{"location":"reference/namespaces/#nanopub.namespaces.HYCL","title":"<code>HYCL = Namespace('http://purl.org/petapico/o/hycl#')</code>  <code>module-attribute</code>","text":"<p>HYCL namespace for claims and hypothesis</p>"},{"location":"reference/namespaces/#nanopub.namespaces.NP","title":"<code>NP = Namespace('http://www.nanopub.org/nschema#')</code>  <code>module-attribute</code>","text":"<p>Nanopub namespace</p>"},{"location":"reference/namespaces/#nanopub.namespaces.NPX","title":"<code>NPX = Namespace('http://purl.org/nanopub/x/')</code>  <code>module-attribute</code>","text":"<p>Nanopub/x namespace</p>"},{"location":"reference/namespaces/#nanopub.namespaces.NTEMPLATE","title":"<code>NTEMPLATE = Namespace('https://w3id.org/np/o/ntemplate/')</code>  <code>module-attribute</code>","text":"<p>Nanopub template namespace</p>"},{"location":"reference/namespaces/#nanopub.namespaces.ORCID","title":"<code>ORCID = Namespace('https://orcid.org/')</code>  <code>module-attribute</code>","text":"<p>ORCID namespace</p>"},{"location":"reference/namespaces/#nanopub.namespaces.PAV","title":"<code>PAV = Namespace('http://purl.org/pav/')</code>  <code>module-attribute</code>","text":"<p>Provenance And Versioning namespace</p>"},{"location":"reference/namespaces/#nanopub.namespaces.PMID","title":"<code>PMID = Namespace('http://www.ncbi.nlm.nih.gov/pubmed/')</code>  <code>module-attribute</code>","text":"<p>PubMed namespace</p>"},{"location":"reference/namespaces/#nanopub.namespaces.PROV","title":"<code>PROV = Namespace('http://www.w3.org/ns/prov#')</code>  <code>module-attribute</code>","text":"<p>Provenance Ontogoly (PROV-O) namespace</p>"},{"location":"reference/nanopub/","title":"Nanopub","text":"<p>A Nanopub object, containing: the RDF that defines the nanopublication; configuration for formatting and publishing the nanopub; functions for validating, signing, publishing</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>NanopubConfig</code> <p>Config for the nanopub</p> <code>rdf</code> <code>ConjunctiveGraph</code> <p>The full RDF graph of this nanopublication (quads)</p> <code>assertion</code> <code>Graph</code> <p>The part of the graph describing the assertion.</p> <code>pubinfo</code> <code>Graph</code> <p>The part of the graph describing the publication information.</p> <code>provenance</code> <code>Graph</code> <p>The part of the graph describing the provenance.</p> <code>source_uri</code> <code>str</code> <p>The URI of the nanopublication that this Publication represents (if applicable)</p> <code>introduces_concept</code> <code>BNode</code> <p>The concept that is introduced by this Publication (if applicable)</p> Source code in <code>nanopub/nanopub.py</code> <pre><code>class Nanopub:\n    \"\"\"A Nanopub object, containing: the RDF that defines the nanopublication;\n    configuration for formatting and publishing the nanopub; functions for validating, signing, publishing\n\n    Attributes:\n        config (NanopubConfig): Config for the nanopub\n        rdf (rdflib.ConjunctiveGraph): The full RDF graph of this nanopublication (quads)\n        assertion (rdflib.Graph): The part of the graph describing the assertion.\n        pubinfo (rdflib.Graph): The part of the graph describing the publication information.\n        provenance (rdflib.Graph): The part of the graph describing the provenance.\n        source_uri (str): The URI of the nanopublication that this Publication represents (if applicable)\n        introduces_concept (rdflib.BNode): The concept that is introduced by this Publication (if applicable)\n    \"\"\"\n\n    def __init__(\n        self,\n        source_uri: str = None,\n        assertion: Graph = Graph(),\n        provenance: Graph = Graph(),\n        pubinfo: Graph = Graph(),\n        rdf: Union[ConjunctiveGraph, Path] = None,\n        introduces_concept: BNode = None,\n        conf: NanopubConf = NanopubConf(),\n    ) -&gt; None:\n        self._profile = conf.profile\n        self._source_uri = source_uri\n        self._introduces_concept = introduces_concept\n        self._concept_uri: Optional[str] = None\n        self._conf = deepcopy(conf)\n        self._metadata = NanopubMetadata()\n        self._published = False\n        if self._conf.use_test_server:\n            self._conf.use_server = NANOPUB_TEST_SERVER\n        if self._conf.use_server == NANOPUB_TEST_SERVER:\n            self._conf.use_test_server = True\n\n        # Get the nanopub RDF depending on how it is provided:\n        # source URI, rdflib graph, or file\n        if source_uri:\n            # If source URI provided we retrieve the nanopub from the servers\n            r = requests.get(source_uri + \".\" + NANOPUB_FETCH_FORMAT)\n            if not r.ok and self._conf.use_test_server:\n                nanopub_id = source_uri.rsplit(\"/\", 1)[-1]\n                uri_test = NANOPUB_TEST_SERVER + nanopub_id\n                r = requests.get(uri_test + \".\" + NANOPUB_FETCH_FORMAT)\n            r.raise_for_status()\n            self._rdf = self._preformat_graph(ConjunctiveGraph())\n            self._rdf.parse(data=r.text, format=NANOPUB_FETCH_FORMAT)\n\n            self._metadata = extract_np_metadata(self._rdf)\n        else:\n            # if provided as rdflib graph, or file\n            if isinstance(rdf, ConjunctiveGraph):\n                self._rdf = self._preformat_graph(rdf)\n                self._metadata = extract_np_metadata(self._rdf)\n            elif isinstance(rdf, Path):\n                self._rdf = self._preformat_graph(ConjunctiveGraph())\n                self._rdf.parse(rdf)\n                self._metadata = extract_np_metadata(self._rdf)\n            else:\n                self._rdf = self._preformat_graph(ConjunctiveGraph())\n\n        # Instantiate the different graph from the provided RDF (trig/nquads)\n        self._head = Graph(self._rdf.store, self._metadata.head)\n        self._assertion = Graph(self._rdf.store, self._metadata.assertion)\n        self._provenance = Graph(self._rdf.store, self._metadata.provenance)\n        self._pubinfo = Graph(self._rdf.store, self._metadata.pubinfo)\n\n        self._assertion += assertion\n        self._provenance += provenance\n        self._pubinfo += pubinfo\n        self._bnode_count = 0\n\n        # Concatenate prefixes declarations from all provided graphs in the main graph\n        for user_rdf in [assertion, provenance, pubinfo]:\n            if user_rdf is not None:\n                for prefix, namespace in user_rdf.namespaces():\n                    self._rdf.bind(prefix, namespace)\n\n        # Add Head graph if the nanopub was not provided as trig/nquads\n        if not rdf and not source_uri:\n            self._head.add((\n                self._metadata.namespace[\"\"],\n                RDF.type,\n                NP.Nanopublication\n            ))\n            self._head.add((\n                self._metadata.namespace[\"\"],\n                NP.hasAssertion,\n                self._assertion.identifier,\n            ))\n            self._head.add((\n                self._metadata.namespace[\"\"],\n                NP.hasProvenance,\n                self._provenance.identifier,\n            ))\n            self._head.add((\n                self._metadata.namespace[\"\"],\n                NP.hasPublicationInfo,\n                self._pubinfo.identifier,\n            ))\n\n        # Add triples to the nanopub depending on the provided NanopuConf (e.g. creator, date)\n        self._validate_nanopub_arguments(\n            introduces_concept=introduces_concept,\n            derived_from=self._conf.derived_from,\n            assertion_attributed_to=self._conf.assertion_attributed_to,\n            attribute_assertion_to_profile=self._conf.attribute_assertion_to_profile,\n            # publication_attributed_to=publication_attributed_to,\n        )\n        self._handle_generated_at_time(\n            self._conf.add_pubinfo_generated_time,\n            self._conf.add_prov_generated_time\n        )\n        assertion_attributed_to = self._conf.assertion_attributed_to\n        if self._conf.attribute_assertion_to_profile:\n            assertion_attributed_to = rdflib.URIRef(self.profile.orcid_id)\n        self._handle_assertion_attributed_to(assertion_attributed_to)\n        self._handle_publication_attributed_to(\n            self._conf.attribute_publication_to_profile,\n            self._conf.publication_attributed_to\n        )\n        self._handle_derived_from(derived_from=self._conf.derived_from)\n\n\n    def _preformat_graph(self, g: ConjunctiveGraph) -&gt; ConjunctiveGraph:\n        \"\"\"Add a few default namespaces\"\"\"\n        g.bind(\"np\", NP)\n        g.bind(\"npx\", NPX)\n        g.bind(\"prov\", PROV)\n        g.bind(\"pav\", PAV)\n        g.bind(\"hycl\", HYCL)\n        g.bind(\"dc\", DC)\n        g.bind(\"dcterms\", DCTERMS)\n        g.bind(\"orcid\", ORCID)\n        g.bind(\"ntemplate\", NTEMPLATE)\n        g.bind(\"foaf\", FOAF)\n        g = self._replace_blank_nodes(g)\n        return g\n\n\n    def update_from_signed(self, signed_g: ConjunctiveGraph) -&gt; None:\n        \"\"\"Update the pub RDF to the signed one\"\"\"\n        self._metadata = extract_np_metadata(signed_g)\n        if self._metadata.trusty:\n            self._source_uri = str(self._metadata.np_uri)\n        # self._source_uri = self.get_source_uri_from_graph\n        self._rdf = signed_g\n        self._head = Graph(self._rdf.store, self._metadata.head)\n        self._assertion = Graph(self._rdf.store, self._metadata.assertion)\n        self._provenance = Graph(self._rdf.store, self._metadata.provenance)\n        self._pubinfo = Graph(self._rdf.store, self._metadata.pubinfo)\n\n\n    def sign(self) -&gt; None:\n        \"\"\"Sign a Nanopub object\"\"\"\n        if len(self.rdf) &gt; MAX_TRIPLES_PER_NANOPUB:\n            raise MalformedNanopubError(f\"Nanopublication contains {len(self.rdf)} triples, which is more than the {MAX_TRIPLES_PER_NANOPUB} authorized\")\n        if not self._conf.profile:\n            raise ProfileError(\"Profile not available, cannot sign the nanopub\")\n        if self._metadata.signature:\n            raise MalformedNanopubError(f\"The nanopub have already been signed: {self.source_uri}\")\n\n        if self.is_valid:\n            self._replace_blank_nodes(self._rdf)\n            signed_g = add_signature(self.rdf, self._conf.profile, self._metadata.namespace, self._pubinfo)\n            self.update_from_signed(signed_g)\n            log.info(f\"Signed {self.source_uri}\")\n        else:\n            raise MalformedNanopubError(\"The nanopub is not valid, cannot sign it\")\n\n\n    def publish(self) -&gt; None:\n        \"\"\"Publish a Nanopub object\"\"\"\n        if not self.source_uri:\n            self.sign()\n\n        publish_graph(self.rdf, use_server=self._conf.use_server)\n        log.info(f'Published {self.source_uri} to {self._conf.use_server}')\n        self.published = True\n\n        if self._introduces_concept:\n            # introduces_concept is always a blank node.\n            # If a blank node with name 'step' was passed as introduces_concept, the concept will be\n            # published with a URI that looks like [published nanopub URI]#step.\n            self._concept_uri = f\"{self.source_uri}#{str(self._introduces_concept)}\"\n            log.info(f\"Published concept to {self._concept_uri}\")\n\n\n    def update(self, publish=True) -&gt; None:\n        \"\"\"Re-publish an updated Nanopub object\"\"\"\n        self._pubinfo.add((\n            URIRef(self.source_uri),\n            NPX.supersedes,\n            URIRef(self.source_uri),\n        ))\n        self._pubinfo.remove((\n            self._metadata.sig_uri,\n            None,\n            None,\n        ))\n        self._metadata = extract_np_metadata(self._rdf)\n        if publish:\n            self.publish()\n        else:\n            self.sign()\n\n\n    def store(self, filepath: Path, format: str = 'trig') -&gt; None:\n        \"\"\"Store the Nanopub object at the given path\"\"\"\n        self._rdf.serialize(filepath, format=format)\n\n\n    @property\n    def has_valid_signature(self) -&gt; bool:\n        verify_signature(self._rdf, self._metadata.namespace)\n        return True\n\n    @property\n    def has_valid_trusty(self) -&gt; bool:\n        verify_trusty(self._rdf, self.source_uri, self._metadata.namespace)\n        return True\n\n    @property\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if a nanopublication is valid\"\"\"\n        np_meta = extract_np_metadata(self._rdf)\n        np_uri = np_meta.np_uri\n\n        # Check if any of the graph is empty\n        if len(self._head) &lt; 1:\n            raise MalformedNanopubError(\"The Head graph is empty\")\n        if len(self._assertion) &lt; 1:\n            raise MalformedNanopubError(\"The assertion graph is empty\")\n        if len(self._provenance) &lt; 1:\n            raise MalformedNanopubError(\"The provenance graph is empty\")\n        if len(self._pubinfo) &lt; 1:\n            raise MalformedNanopubError(\"The pubinfo graph is empty\")\n\n        # Check exactly 4 graphs\n        graph_count = 0\n        for c in self._rdf.contexts():\n            if len(list(self._rdf.quads((None, None, None, c)))) &gt; 0:\n                graph_count += 1\n        if graph_count != 4:\n            raise MalformedNanopubError(f\"\\033[1mToo many graphs found\\033[0m in the provided RDF: {graph_count}. A Nanopub should have only 4 graphs (Head, assertion, provenance, pubinfo)\")\n\n        found_prov = False\n        for s, p, o in self._provenance:\n            if str(s) == str(np_meta.assertion):\n                found_prov = True\n                break\n        if not found_prov:\n            raise MalformedNanopubError(f\"The provenance graph should contain at least one triple with the assertion graph URI as subject: \\033[1m{np_meta.assertion}\\033[0m\")\n\n        found_pubinfo = False\n        for s, p, o in self._pubinfo:\n            if str(s) == str(np_uri) or str(s) == str(np_meta.namespace):\n                found_pubinfo = True\n                break\n        if not found_pubinfo:\n            raise MalformedNanopubError(f\"The pubinfo graph should contain at least one triple that has the nanopub URI as subject: \\033[1m{np_uri}\\033[0m\")\n\n        # TODO: add more checks for trusty and signature\n        # if self._metadata.signature:\n        #     if self.has_valid_signature is False:\n        #         raise MalformedNanopubError(\"The nanopub is not valid\")\n        return True\n\n\n    @property\n    def rdf(self) -&gt; ConjunctiveGraph:\n        return self._rdf\n\n    @property\n    def head(self):\n        return self._head\n\n    @property\n    def assertion(self):\n        return self._assertion\n\n    @property\n    def provenance(self):\n        return self._provenance\n\n    @property\n    def pubinfo(self):\n        return self._pubinfo\n\n    @property\n    def metadata(self):\n        return self._metadata\n\n    @property\n    def conf(self):\n        return self._conf\n\n    @conf.setter\n    def conf(self, value):\n        self._conf = value\n\n    @property\n    def source_uri(self):\n        # return self._source_uri\n        if self._source_uri:\n            return self._source_uri\n        else:\n            return self.get_source_uri_from_graph\n\n    @source_uri.setter\n    def source_uri(self, value):\n        self._source_uri = value\n\n    @property\n    def published(self):\n        return self._published\n\n    @published.setter\n    def published(self, value):\n        self._published = value\n\n    @property\n    def concept_uri(self):\n        return self._concept_uri\n\n    @concept_uri.setter\n    def concept_uri(self, value):\n        self._concept_uri = value\n\n    @property\n    def profile(self):\n        return self._profile\n\n    @profile.setter\n    def profile(self, value):\n        self._profile = value\n\n    @property\n    def namespace(self):\n        return self._metadata.namespace\n\n\n\n    @property\n    def introduces_concept(self):\n        concepts_introduced = list()\n        for s, p, o in self._pubinfo.triples((None, NPX.introduces, None)):\n            concepts_introduced.append(o)\n\n        if len(concepts_introduced) == 0:\n            return None\n        elif len(concepts_introduced) == 1:\n            return concepts_introduced[0]\n        else:\n            raise MalformedNanopubError(\"Nanopub introduces multiple concepts\")\n\n\n    @property\n    def get_source_uri_from_graph(self) -&gt; Optional[str]:\n        \"\"\"Get the source URI of the nanopublication from the header.\n\n        This is usually something like: http://purl.org/np/RAnksi2yDP7jpe7F6BwWCpMOmzBEcUImkAKUeKEY_2Yus\n        \"\"\"\n        for s in self._rdf.subjects(rdflib.RDF.type, NP.Nanopublication):\n            extract_trusty = re.search(r'^[a-z0-9+.-]+:\\/\\/[a-zA-Z0-9\\/._-]+\\/(RA.*)$', str(s), re.IGNORECASE)\n            if extract_trusty:\n                return str(s)\n        return None\n\n\n    @property\n    def signed_with_public_key(self) -&gt; Optional[str]:\n        np_sig = extract_np_metadata(self._rdf)\n        if np_sig.public_key:\n            return np_sig.public_key\n        return None\n\n\n    @property\n    def is_test_publication(self) -&gt; bool:\n        return self._conf.use_test_server\n\n\n    def __str__(self) -&gt; str:\n        s = \"\"\n        if self._source_uri:\n            s += f\"Nanopub URI: \\033[1m{self._source_uri}\\033[0m\\n\"\n        s += self._rdf.serialize(format='trig')\n        return s\n\n\n    def _handle_generated_at_time(\n        self, add_pubinfo_generated_time: bool, add_prov_generated_time: bool\n    ) -&gt; None:\n        \"\"\"Handler for `Nanopub` constructor.\"\"\"\n        creationtime = rdflib.Literal(datetime.now(), datatype=XSD.dateTime)\n        if add_pubinfo_generated_time:\n            self._pubinfo.add(\n                (self._metadata.namespace[\"\"], PROV.generatedAtTime, creationtime)\n            )\n        if add_prov_generated_time:\n            self._provenance.add(\n                (\n                    self._assertion.identifier,\n                    PROV.generatedAtTime,\n                    creationtime,\n                )\n            )\n\n\n    def _handle_assertion_attributed_to(self, assertion_attributed_to: Optional[str]) -&gt; None:\n        \"\"\"Handler for `Nanopub` constructor.\"\"\"\n        if assertion_attributed_to:\n            assertion_attributed_to = URIRef(assertion_attributed_to)\n            self._provenance.add(\n                (\n                    self._assertion.identifier,\n                    PROV.wasAttributedTo,\n                    assertion_attributed_to,\n                )\n            )\n\n\n    def _handle_publication_attributed_to(\n        self,\n        attribute_publication_to_profile: bool,\n        publication_attributed_to: Optional[str],\n    ) -&gt; None:\n        \"\"\"Handler for `Nanopub` constructor.\"\"\"\n        if attribute_publication_to_profile:\n            if not self._profile:\n                raise MalformedNanopubError(\"No nanopub profile provided, but attribute_publication_to_profile is enabled\")\n            if publication_attributed_to is None:\n                publication_attributed_to = rdflib.URIRef(self._profile.orcid_id)\n            else:\n                publication_attributed_to = rdflib.URIRef(publication_attributed_to)\n            self._pubinfo.add(\n                (\n                    self._metadata.namespace[\"\"],\n                    PROV.wasAttributedTo,\n                    publication_attributed_to,\n                )\n            )\n\n\n    def _handle_derived_from(self, derived_from: Optional[str]):\n        \"\"\"Handler for `Nanopub` constructor.\"\"\"\n        if derived_from:\n            if isinstance(derived_from, list):\n                list_of_uris = derived_from\n            else:\n                list_of_uris = [derived_from]\n\n            for derived_from_uri in list_of_uris:\n                derived_from_uri = rdflib.URIRef(derived_from_uri)\n                self._provenance.add((\n                    self._assertion.identifier,\n                    PROV.wasDerivedFrom,\n                    derived_from_uri,\n                ))\n\n    def _handle_introduces_concept(self, introduces_concept: Union[BNode, URIRef]):\n        \"\"\"Handler for `Nanopub` constructor.\"\"\"\n        if introduces_concept:\n            introduces_concept = self._metadata.namespace[str(introduces_concept)]\n            self._pubinfo.add(\n                (self._metadata.namespace[\"\"], NPX.introduces, introduces_concept)\n            )\n\n    def _validate_nanopub_arguments(\n        self,\n        derived_from: Optional[str],\n        assertion_attributed_to: Optional[str],\n        attribute_assertion_to_profile: bool,\n        introduces_concept: Optional[BNode],\n    ) -&gt; None:\n        \"\"\"\n        Validate arguments method.\n        \"\"\"\n        if assertion_attributed_to and attribute_assertion_to_profile:\n            raise MalformedNanopubError(\n                \"If you pass a URI for the assertion_attributed_to argument, you cannot pass \"\n                \"attribute_assertion_to_profile=True, because the assertion will already be \"\n                \"attributed to the value passed in assertion_attributed_to argument. Set \"\n                \"attribute_assertion_to_profile=False or do not pass the assertion_attributed_to \"\n                \"argument.\"\n            )\n\n        if introduces_concept and not isinstance(introduces_concept, BNode):\n            raise MalformedNanopubError(\n                \"If you want a nanopublication to introduce a concept, you need to \"\n                'pass it as an rdflib.term.BNode(\"concept_name\"). This will make '\n                \"sure it is referred to from the nanopublication uri namespace upon \"\n                \"publishing.\"\n            )\n\n        if self._provenance:\n            if (\n                derived_from\n                and (None, PROV.wasDerivedFrom, None) in self._provenance\n            ):\n                raise MalformedNanopubError(\n                    \"The provenance_rdf that you passed already contains the \"\n                    \"prov:wasDerivedFrom predicate, so you cannot also use the \"\n                    \"derived_from argument\"\n                )\n            if (\n                assertion_attributed_to\n                and (None, PROV.wasAttributedTo, None) in self._provenance\n            ):\n                raise MalformedNanopubError(\n                    \"The provenance_rdf that you passed already contains the \"\n                    \"prov:wasAttributedTo predicate, so you cannot also use the \"\n                    \"assertion_attributed_to argument\"\n                )\n            if (\n                attribute_assertion_to_profile\n                and (None, PROV.wasAttributedTo, None) in self._provenance\n            ):\n                raise MalformedNanopubError(\n                    \"The provenance_rdf that you passed already contains the \"\n                    \"prov:wasAttributedTo predicate, so you cannot also use the \"\n                    \"attribute_assertion_to_profile argument\"\n                )\n        if self._pubinfo:\n            if (\n                introduces_concept\n                and (None, NPX.introduces, None) in self._pubinfo\n            ):\n                raise MalformedNanopubError(\n                    \"The pubinfo_rdf that you passed already contains the \"\n                    \"npx:introduces predicate, so you cannot also use the \"\n                    \"introduces_concept argument\"\n                )\n\n\n    def _replace_blank_nodes(self, g: ConjunctiveGraph) -&gt; ConjunctiveGraph:\n        \"\"\"Replace blank nodes.\n          Replace any blank nodes in the supplied RDF with a corresponding uri in the\n        dummy_namespace.'Blank nodes' here refers specifically to rdflib.term.BNode objects. When\n        publishing, the dummy_namespace is replaced with the URI of the actual nanopublication.\n          For example, if the nanopub's URI is www.purl.org/ABC123 then the blank node will be\n        replaced with a concrete URIRef of the form www.purl.org/ABC123#blanknodename where\n        'blanknodename' is the name of the rdflib.term.BNode object.\n          This is to solve the problem that a user may wish to use the nanopublication to introduce\n        a new concept. This new concept needs its own URI (it cannot simply be given the\n        nanopublication's URI), but it should still lie within the space of the nanopub.\n        Furthermore, the URI the nanopub is published to is not known ahead of time.\n        \"\"\"\n        bnode_map: dict = {}\n        for s, p, o, c in g.quads():\n            if isinstance(s, BNode):\n                g.remove((s, p, o, c))\n                if str(s) not in bnode_map:\n                    if re.match(r'^[Na-zA-Z0-9]{33}$', str(s)):\n                        # Unnamed BNode looks like N2c21867a547345d9b8a203a7c1cd7e0c\n                        self._bnode_count += 1\n                        bnode_map[str(s)] = self._bnode_count\n                    else:\n                        bnode_map[str(s)] = str(s)\n                s = self._metadata.namespace[f\"_{bnode_map[str(s)]}\"]\n                g.add((s, p, o, c))\n\n            if isinstance(o, BNode):\n                g.remove((s, p, o, c))\n                if str(o) not in bnode_map:\n                    # if str(o).startswith(\"N\") and len(str(o)) == 33:\n                    if re.match(r'^[Na-zA-Z0-9]{33}$', str(s)):\n                        self._bnode_count += 1\n                        bnode_map[str(o)] = self._bnode_count\n                    else:\n                        bnode_map[str(o)] = str(o)\n                o = self._metadata.namespace[f\"_{bnode_map[str(o)]}\"]\n\n                g.add((s, p, o, c))\n        return g\n</code></pre>"},{"location":"reference/nanopub/#nanopub.Nanopub.get_source_uri_from_graph","title":"<code>get_source_uri_from_graph: Optional[str]</code>  <code>property</code>","text":"<p>Get the source URI of the nanopublication from the header.</p> <p>This is usually something like: http://purl.org/np/RAnksi2yDP7jpe7F6BwWCpMOmzBEcUImkAKUeKEY_2Yus</p>"},{"location":"reference/nanopub/#nanopub.Nanopub.is_valid","title":"<code>is_valid: bool</code>  <code>property</code>","text":"<p>Check if a nanopublication is valid</p>"},{"location":"reference/nanopub/#nanopub.Nanopub.publish","title":"<code>publish()</code>","text":"<p>Publish a Nanopub object</p> Source code in <code>nanopub/nanopub.py</code> <pre><code>def publish(self) -&gt; None:\n    \"\"\"Publish a Nanopub object\"\"\"\n    if not self.source_uri:\n        self.sign()\n\n    publish_graph(self.rdf, use_server=self._conf.use_server)\n    log.info(f'Published {self.source_uri} to {self._conf.use_server}')\n    self.published = True\n\n    if self._introduces_concept:\n        # introduces_concept is always a blank node.\n        # If a blank node with name 'step' was passed as introduces_concept, the concept will be\n        # published with a URI that looks like [published nanopub URI]#step.\n        self._concept_uri = f\"{self.source_uri}#{str(self._introduces_concept)}\"\n        log.info(f\"Published concept to {self._concept_uri}\")\n</code></pre>"},{"location":"reference/nanopub/#nanopub.Nanopub.sign","title":"<code>sign()</code>","text":"<p>Sign a Nanopub object</p> Source code in <code>nanopub/nanopub.py</code> <pre><code>def sign(self) -&gt; None:\n    \"\"\"Sign a Nanopub object\"\"\"\n    if len(self.rdf) &gt; MAX_TRIPLES_PER_NANOPUB:\n        raise MalformedNanopubError(f\"Nanopublication contains {len(self.rdf)} triples, which is more than the {MAX_TRIPLES_PER_NANOPUB} authorized\")\n    if not self._conf.profile:\n        raise ProfileError(\"Profile not available, cannot sign the nanopub\")\n    if self._metadata.signature:\n        raise MalformedNanopubError(f\"The nanopub have already been signed: {self.source_uri}\")\n\n    if self.is_valid:\n        self._replace_blank_nodes(self._rdf)\n        signed_g = add_signature(self.rdf, self._conf.profile, self._metadata.namespace, self._pubinfo)\n        self.update_from_signed(signed_g)\n        log.info(f\"Signed {self.source_uri}\")\n    else:\n        raise MalformedNanopubError(\"The nanopub is not valid, cannot sign it\")\n</code></pre>"},{"location":"reference/nanopub/#nanopub.Nanopub.store","title":"<code>store(filepath, format='trig')</code>","text":"<p>Store the Nanopub object at the given path</p> Source code in <code>nanopub/nanopub.py</code> <pre><code>def store(self, filepath: Path, format: str = 'trig') -&gt; None:\n    \"\"\"Store the Nanopub object at the given path\"\"\"\n    self._rdf.serialize(filepath, format=format)\n</code></pre>"},{"location":"reference/nanopub/#nanopub.Nanopub.update","title":"<code>update(publish=True)</code>","text":"<p>Re-publish an updated Nanopub object</p> Source code in <code>nanopub/nanopub.py</code> <pre><code>def update(self, publish=True) -&gt; None:\n    \"\"\"Re-publish an updated Nanopub object\"\"\"\n    self._pubinfo.add((\n        URIRef(self.source_uri),\n        NPX.supersedes,\n        URIRef(self.source_uri),\n    ))\n    self._pubinfo.remove((\n        self._metadata.sig_uri,\n        None,\n        None,\n    ))\n    self._metadata = extract_np_metadata(self._rdf)\n    if publish:\n        self.publish()\n    else:\n        self.sign()\n</code></pre>"},{"location":"reference/nanopub/#nanopub.Nanopub.update_from_signed","title":"<code>update_from_signed(signed_g)</code>","text":"<p>Update the pub RDF to the signed one</p> Source code in <code>nanopub/nanopub.py</code> <pre><code>def update_from_signed(self, signed_g: ConjunctiveGraph) -&gt; None:\n    \"\"\"Update the pub RDF to the signed one\"\"\"\n    self._metadata = extract_np_metadata(signed_g)\n    if self._metadata.trusty:\n        self._source_uri = str(self._metadata.np_uri)\n    # self._source_uri = self.get_source_uri_from_graph\n    self._rdf = signed_g\n    self._head = Graph(self._rdf.store, self._metadata.head)\n    self._assertion = Graph(self._rdf.store, self._metadata.assertion)\n    self._provenance = Graph(self._rdf.store, self._metadata.provenance)\n    self._pubinfo = Graph(self._rdf.store, self._metadata.pubinfo)\n</code></pre>"},{"location":"reference/profile/","title":"Profile","text":"<p>This module holds objects and functions to load a nanopub user profile.</p>"},{"location":"reference/profile/#nanopub.profile.Profile","title":"<code>Profile</code>","text":"<p>Represents a user profile.</p> <p>Attributes:</p> Name Type Description <code>orcid_id</code> <code>str</code> <p>The user\u2019s ORCID</p> <code>name</code> <code>str</code> <p>The user\u2019s name</p> <code>private_key</code> <code>Optional[Union[Path, str]]</code> <p>Path to the user\u2019s private key, or the key as string</p> <code>public_key</code> <code>Optional[Union[Path, str]]</code> <p>Path to the user\u2019s public key, or the key as string</p> <code>introduction_nanopub_uri</code> <code>Optional[str]</code> <p>URI of the user\u2019s profile nanopub</p> Source code in <code>nanopub/profile.py</code> <pre><code>class Profile:\n    \"\"\"Represents a user profile.\n\n    Attributes:\n        orcid_id (str): The user's ORCID\n        name (str): The user's name\n        private_key (Optional[Union[Path, str]]): Path to the user's private key, or the key as string\n        public_key (Optional[Union[Path, str]]): Path to the user's public key, or the key as string\n        introduction_nanopub_uri (Optional[str]): URI of the user's profile nanopub\n    \"\"\"\n\n    def __init__(\n            self,\n            orcid_id: str,\n            name: str,\n            private_key: Optional[Union[Path, str]] = None,\n            public_key: Optional[Union[Path, str]] = None,\n            introduction_nanopub_uri: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Create a Profile.\"\"\"\n        self._orcid_id = orcid_id\n        self._name = name\n        self._introduction_nanopub_uri = introduction_nanopub_uri\n\n        if not private_key:\n            self.generate_keys()\n        elif isinstance(private_key, Path):\n            try:\n                with open(private_key) as f:\n                    self._private_key = f.read().strip()\n            except FileNotFoundError:\n                raise ProfileError(\n                    f'Private key file {private_key} for nanopub not found.\\n'\n                    f'Maybe your nanopub profile was not set up yet or not set up '\n                    f'correctly. \\n{PROFILE_INSTRUCTIONS_MESSAGE}'\n                )\n        else:\n            self._private_key = private_key\n\n        if not public_key and private_key:\n            log.info('The public key was not provided when loading the Nanopub profile, generating it from the provided private key')\n            key = RSA.import_key(decodebytes(self._private_key.encode()))\n            self._public_key = format_key(key.publickey().export_key().decode('utf-8'))\n        elif isinstance(public_key, Path):\n            try:\n                with open(public_key) as f:\n                    self._public_key = f.read().strip()\n            except FileNotFoundError:\n                raise ProfileError(\n                    f'Private key file {public_key} for nanopub not found.\\n'\n                    f'Maybe your nanopub profile was not set up yet or not set up '\n                    f'correctly. \\n{PROFILE_INSTRUCTIONS_MESSAGE}'\n                )\n        elif public_key:\n            self._public_key = public_key\n\n    def generate_keys(self) -&gt; str:\n        \"\"\"Generate private/public RSA key pair at the path specified in the profile.yml, to be used to sign nanopubs\"\"\"\n        key = RSA.generate(RSA_KEY_SIZE)\n        private_key_str = key.export_key('PEM', pkcs=8).decode('utf-8')\n        public_key_str = key.publickey().export_key().decode('utf-8')\n\n        self._private_key = format_key(private_key_str)\n        self._public_key = format_key(public_key_str)\n        log.info(f\"Public/private RSA key pair has been generated for {self.orcid_id} ({self.name})\")\n        return public_key_str\n\n\n    def store(self, folder: Path = USER_CONFIG_DIR) -&gt; str:\n        \"\"\"Stores the nanopub user profile. By default the profile is stored in `HOME_DIR/.nanopub/profile.yaml`.\n\n        Args:\n            folder: The path to the folder to store the user's profile files.\n\n        Returns:\n            The path where the profile was stored.\n        \"\"\"\n        folder = Path(folder)\n        folder.mkdir(parents=True, exist_ok=True)\n        private_key_path = os.path.join(folder, \"id_rsa\")\n        public_key_path = os.path.join(folder, \"id_rsa.pub\")\n        profile_path = os.path.join(folder, \"profile.yml\")\n\n        # Store keys\n        if not os.path.exists(private_key_path):\n            with open(private_key_path, \"w\") as f:\n                f.write(self.private_key + '\\n')\n        if not os.path.exists(public_key_path):\n            with open(public_key_path, \"w\") as f:\n                f.write(self.public_key)\n\n        intro_uri = ''\n        if self.introduction_nanopub_uri:\n            intro_uri = f\" {self.introduction_nanopub_uri}\"\n        # Store profile.yml\n        profile_yaml = f\"\"\"orcid_id: {self.orcid_id}\nname: {self.name}\npublic_key: {public_key_path}\nprivate_key: {private_key_path}\nintroduction_nanopub_uri:{intro_uri}\n\"\"\"\n        with open(profile_path, \"w\") as f:\n            f.write(profile_yaml)\n\n        return profile_path\n\n\n    @property\n    def orcid_id(self):\n        return self._orcid_id\n\n    @orcid_id.setter\n    def orcid_id(self, value):\n        self._orcid_id = value\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\n    @property\n    def private_key(self):\n        return self._private_key\n\n    @private_key.setter\n    def private_key(self, value):\n        self._private_key = value\n\n    @property\n    def public_key(self):\n        return self._public_key\n\n    @public_key.setter\n    def public_key(self, value):\n        self._public_key = value\n\n    @property\n    def introduction_nanopub_uri(self):\n        return self._introduction_nanopub_uri\n\n    @introduction_nanopub_uri.setter\n    def introduction_nanopub_uri(self, value):\n        self._introduction_nanopub_uri = value\n\n\n    def __repr__(self):\n        return f\"\"\"\\033[1mORCID\\033[0m: {self._orcid_id}\n\\033[1mName\\033[0m: {self._name}\n\\033[1mPrivate key\\033[0m: {self._private_key}\n\\033[1mPublic key\\033[0m: {self._public_key}\n\\033[1mIntro Nanopub URI\\033[0m: {self._introduction_nanopub_uri}\"\"\"\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.Profile.__init__","title":"<code>__init__(orcid_id, name, private_key=None, public_key=None, introduction_nanopub_uri=None)</code>","text":"<p>Create a Profile.</p> Source code in <code>nanopub/profile.py</code> <pre><code>def __init__(\n        self,\n        orcid_id: str,\n        name: str,\n        private_key: Optional[Union[Path, str]] = None,\n        public_key: Optional[Union[Path, str]] = None,\n        introduction_nanopub_uri: Optional[str] = None\n) -&gt; None:\n    \"\"\"Create a Profile.\"\"\"\n    self._orcid_id = orcid_id\n    self._name = name\n    self._introduction_nanopub_uri = introduction_nanopub_uri\n\n    if not private_key:\n        self.generate_keys()\n    elif isinstance(private_key, Path):\n        try:\n            with open(private_key) as f:\n                self._private_key = f.read().strip()\n        except FileNotFoundError:\n            raise ProfileError(\n                f'Private key file {private_key} for nanopub not found.\\n'\n                f'Maybe your nanopub profile was not set up yet or not set up '\n                f'correctly. \\n{PROFILE_INSTRUCTIONS_MESSAGE}'\n            )\n    else:\n        self._private_key = private_key\n\n    if not public_key and private_key:\n        log.info('The public key was not provided when loading the Nanopub profile, generating it from the provided private key')\n        key = RSA.import_key(decodebytes(self._private_key.encode()))\n        self._public_key = format_key(key.publickey().export_key().decode('utf-8'))\n    elif isinstance(public_key, Path):\n        try:\n            with open(public_key) as f:\n                self._public_key = f.read().strip()\n        except FileNotFoundError:\n            raise ProfileError(\n                f'Private key file {public_key} for nanopub not found.\\n'\n                f'Maybe your nanopub profile was not set up yet or not set up '\n                f'correctly. \\n{PROFILE_INSTRUCTIONS_MESSAGE}'\n            )\n    elif public_key:\n        self._public_key = public_key\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.Profile.generate_keys","title":"<code>generate_keys()</code>","text":"<p>Generate private/public RSA key pair at the path specified in the profile.yml, to be used to sign nanopubs</p> Source code in <code>nanopub/profile.py</code> <pre><code>def generate_keys(self) -&gt; str:\n    \"\"\"Generate private/public RSA key pair at the path specified in the profile.yml, to be used to sign nanopubs\"\"\"\n    key = RSA.generate(RSA_KEY_SIZE)\n    private_key_str = key.export_key('PEM', pkcs=8).decode('utf-8')\n    public_key_str = key.publickey().export_key().decode('utf-8')\n\n    self._private_key = format_key(private_key_str)\n    self._public_key = format_key(public_key_str)\n    log.info(f\"Public/private RSA key pair has been generated for {self.orcid_id} ({self.name})\")\n    return public_key_str\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.Profile.store","title":"<code>store(folder=USER_CONFIG_DIR)</code>","text":"<p>Stores the nanopub user profile. By default the profile is stored in <code>HOME_DIR/.nanopub/profile.yaml</code>.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Path</code> <p>The path to the folder to store the user\u2019s profile files.</p> <code>USER_CONFIG_DIR</code> <p>Returns:</p> Type Description <code>str</code> <p>The path where the profile was stored.</p> Source code in <code>nanopub/profile.py</code> <pre><code>    def store(self, folder: Path = USER_CONFIG_DIR) -&gt; str:\n        \"\"\"Stores the nanopub user profile. By default the profile is stored in `HOME_DIR/.nanopub/profile.yaml`.\n\n        Args:\n            folder: The path to the folder to store the user's profile files.\n\n        Returns:\n            The path where the profile was stored.\n        \"\"\"\n        folder = Path(folder)\n        folder.mkdir(parents=True, exist_ok=True)\n        private_key_path = os.path.join(folder, \"id_rsa\")\n        public_key_path = os.path.join(folder, \"id_rsa.pub\")\n        profile_path = os.path.join(folder, \"profile.yml\")\n\n        # Store keys\n        if not os.path.exists(private_key_path):\n            with open(private_key_path, \"w\") as f:\n                f.write(self.private_key + '\\n')\n        if not os.path.exists(public_key_path):\n            with open(public_key_path, \"w\") as f:\n                f.write(self.public_key)\n\n        intro_uri = ''\n        if self.introduction_nanopub_uri:\n            intro_uri = f\" {self.introduction_nanopub_uri}\"\n        # Store profile.yml\n        profile_yaml = f\"\"\"orcid_id: {self.orcid_id}\nname: {self.name}\npublic_key: {public_key_path}\nprivate_key: {private_key_path}\nintroduction_nanopub_uri:{intro_uri}\n\"\"\"\n        with open(profile_path, \"w\") as f:\n            f.write(profile_yaml)\n\n        return profile_path\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.ProfileError","title":"<code>ProfileError</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Error to be raised if profile is not setup correctly.</p> Source code in <code>nanopub/profile.py</code> <pre><code>class ProfileError(RuntimeError):\n    \"\"\"\n    Error to be raised if profile is not setup correctly.\n    \"\"\"\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.ProfileLoader","title":"<code>ProfileLoader</code>","text":"<p>             Bases: <code>Profile</code></p> <p>A class to load a user profile from a local YAML file, only used for YAtiML.</p> Source code in <code>nanopub/profile.py</code> <pre><code>class ProfileLoader(Profile):\n    \"\"\"A class to load a user profile from a local YAML file, only used for YAtiML.\"\"\"\n    def __init__(\n            self,\n            orcid_id: str,\n            name: str,\n            private_key: Path,\n            public_key: Optional[Path],\n            introduction_nanopub_uri: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Create a ProfileLoader.\"\"\"\n        super().__init__(\n            orcid_id=orcid_id,\n            name=name,\n            private_key=private_key,\n            public_key=public_key,\n            introduction_nanopub_uri=introduction_nanopub_uri,\n        )\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.ProfileLoader.__init__","title":"<code>__init__(orcid_id, name, private_key, public_key, introduction_nanopub_uri=None)</code>","text":"<p>Create a ProfileLoader.</p> Source code in <code>nanopub/profile.py</code> <pre><code>def __init__(\n        self,\n        orcid_id: str,\n        name: str,\n        private_key: Path,\n        public_key: Optional[Path],\n        introduction_nanopub_uri: Optional[str] = None\n) -&gt; None:\n    \"\"\"Create a ProfileLoader.\"\"\"\n    super().__init__(\n        orcid_id=orcid_id,\n        name=name,\n        private_key=private_key,\n        public_key=public_key,\n        introduction_nanopub_uri=introduction_nanopub_uri,\n    )\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.format_key","title":"<code>format_key(key)</code>","text":"<p>Format private and public keys to remove header/footer and all newlines, as this is required by nanopub-java</p> Source code in <code>nanopub/profile.py</code> <pre><code>def format_key(key: str) -&gt; str:\n    \"\"\"Format private and public keys to remove header/footer and all newlines, as this is required by nanopub-java\"\"\"\n    if key.startswith(\"-----BEGIN PRIVATE KEY-----\"):\n        key = key.replace(\"-----BEGIN PRIVATE KEY-----\", \"\").replace(\"-----END PRIVATE KEY-----\", \"\")\n    if key.startswith(\"-----BEGIN PUBLIC KEY-----\"):\n        key = key.replace(\"-----BEGIN PUBLIC KEY-----\", \"\").replace(\"-----END PUBLIC KEY-----\", \"\")\n    return key.replace(\"\\n\", \"\").strip()\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.generate_keyfiles","title":"<code>generate_keyfiles(path=USER_CONFIG_DIR)</code>","text":"<p>Generate private/public RSA key pair at the path specified in the profile.yml, to be used to sign nanopubs</p> Source code in <code>nanopub/profile.py</code> <pre><code>def generate_keyfiles(path: Path = USER_CONFIG_DIR) -&gt; str:\n    \"\"\"Generate private/public RSA key pair at the path specified in the profile.yml, to be used to sign nanopubs\"\"\"\n    if not Path(path).exists():\n        Path(path).mkdir()\n\n    key = RSA.generate(RSA_KEY_SIZE)\n    private_key_str = key.export_key('PEM', pkcs=8).decode('utf-8')\n    public_key_str = key.publickey().export_key().decode('utf-8')\n\n    private_key_str = format_key(private_key_str)\n    public_key_str = format_key(public_key_str)\n    private_path = path / \"id_rsa\"\n    public_path = path / \"id_rsa.pub\"\n\n    # Store key pair\n    private_key_file = open(private_path, \"w\")\n    private_key_file.write(private_key_str)\n    private_key_file.close()\n\n    public_key_file = open(public_path, \"w\")\n    public_key_file.write(public_key_str)\n    public_key_file.close()\n    log.info(f\"Public/private RSA key pair has been generated in {private_path} and {public_path}\")\n    return public_key_str\n</code></pre>"},{"location":"reference/profile/#nanopub.profile.load_profile","title":"<code>load_profile(profile_path=DEFAULT_PROFILE_PATH)</code>","text":"<p>Retrieve nanopub user profile.</p> <p>By default the profile is stored in <code>HOME_DIR/.nanopub/profile.yaml</code>.</p> <p>Returns:</p> Type Description <code>Profile</code> <p>A Profile containing the data from the configuration file.</p> <p>Raises:</p> Type Description <code>RecognitionError</code> <p>If there is an error in the file.</p> Source code in <code>nanopub/profile.py</code> <pre><code>def load_profile(profile_path: Union[Path, str] = DEFAULT_PROFILE_PATH) -&gt; Profile:\n    \"\"\"Retrieve nanopub user profile.\n\n    By default the profile is stored in `HOME_DIR/.nanopub/profile.yaml`.\n\n    Returns:\n        A Profile containing the data from the configuration file.\n\n    Raises:\n        yatiml.RecognitionError: If there is an\n            error in the file.\n    \"\"\"\n    try:\n        return _load_profile(Path(profile_path))\n    except (yatiml.RecognitionError, FileNotFoundError) as e:\n        msg = (f'{e}\\nYour nanopub profile has not been set up yet, or is not set up correctly.\\n'\n               f'{PROFILE_INSTRUCTIONS_MESSAGE}')\n        raise ProfileError(msg)\n</code></pre>"},{"location":"reference/templates/","title":"Nanopublications templates","text":""},{"location":"reference/templates/#nanopub.templates.nanopub_claim.NanopubClaim","title":"<code>NanopubClaim</code>","text":"<p>             Bases: <code>Nanopub</code></p> <p>Quickly claim a statement.</p> <p>Constructs statement triples around the provided text following the Hypotheses and Claims Ontology (http://purl.org/petapico/o/hycl).</p> <p>Parameters:</p> Name Type Description Default <code>conf</code> <code>NanopubConf</code> <p>config for the nanopub</p> required <code>claim</code> <code>str</code> <p>the text of the statement, example: \u2018All cats are grey\u2019</p> required Source code in <code>nanopub/templates/nanopub_claim.py</code> <pre><code>class NanopubClaim(Nanopub):\n    \"\"\"Quickly claim a statement.\n\n    Constructs statement triples around the provided text following the Hypotheses and Claims\n    Ontology (http://purl.org/petapico/o/hycl).\n\n    Args:\n        conf: config for the nanopub\n        claim (str): the text of the statement, example: 'All cats are grey'\n    \"\"\"\n\n    def __init__(\n        self,\n        claim: str,\n        conf: NanopubConf,\n    ) -&gt; None:\n        conf = deepcopy(conf)\n        conf.add_prov_generated_time = True\n        conf.add_pubinfo_generated_time = True\n        conf.attribute_publication_to_profile = True\n        super().__init__(\n            conf=conf,\n        )\n\n        if not self.profile:\n            raise ProfileError(\"No profile provided, cannot generate a Nanopub Claim\")\n\n        this_statement = self._metadata.namespace.claim\n        # this_statement = BNode(\"mystatement\")\n        self.assertion.add((this_statement, RDF.type, HYCL.Statement))\n        self.assertion.add((this_statement, RDFS.label, Literal(claim)))\n\n        orcid_id_uri = URIRef(self.profile.orcid_id)\n        self.provenance.add((orcid_id_uri, HYCL.claims, this_statement))\n</code></pre>"},{"location":"reference/templates/#nanopub.templates.nanopub_retract.NanopubRetract","title":"<code>NanopubRetract</code>","text":"<p>             Bases: <code>Nanopub</code></p> <p>Retract a nanopublication.</p> <p>Publish a retraction nanpublication that declares retraction of the nanopublication that corresponds to the \u2018uri\u2019 argument.</p> <p>Parameters:</p> Name Type Description Default <code>conf</code> <code>NanopubConf</code> <p>config for the nanopub</p> required <code>uri</code> <code>str</code> <p>The uri pointing to the to-be-retracted nanopublication</p> required <code>force</code> <code>bool</code> <p>Toggle using force to retract, this will even retract the nanopublication if it is signed with a different public key than the one in the user profile.</p> <code>False</code> Source code in <code>nanopub/templates/nanopub_retract.py</code> <pre><code>class NanopubRetract(Nanopub):\n    \"\"\"Retract a nanopublication.\n\n    Publish a retraction nanpublication that declares retraction of the nanopublication that\n    corresponds to the 'uri' argument.\n\n    Args:\n        conf: config for the nanopub\n        uri (str): The uri pointing to the to-be-retracted nanopublication\n        force (bool): Toggle using force to retract, this will even retract the\n            nanopublication if it is signed with a different public key than the one\n            in the user profile.\n    \"\"\"\n\n    def __init__(\n        self,\n        conf: NanopubConf,\n        uri: str,\n        force: bool = False,\n    ) -&gt; None:\n        conf = deepcopy(conf)\n        conf.add_prov_generated_time = True\n        conf.add_pubinfo_generated_time = True\n        conf.attribute_publication_to_profile = True\n        conf.attribute_assertion_to_profile = True\n        super().__init__(\n            conf=conf,\n        )\n        if not self.profile:\n            raise ProfileError(\"No profile provided, cannot generate a Nanopub to retract another nanopub\")\n\n        if not force:\n            self._check_public_keys_match(uri)\n        orcid_id = self.profile.orcid_id\n        self.assertion.add(\n            (URIRef(orcid_id), NPX.retracts, URIRef(uri))\n        )\n\n\n    def _check_public_keys_match(self, uri):\n        \"\"\"Check for matching public keys of a nanopublication with the profile.\n\n        Raises:\n            AssertionError: When the nanopublication is signed with a public key that does not\n                match the public key in the profile\n        \"\"\"\n        np = Nanopub(\n            uri,\n            conf=NanopubConf(\n                use_test_server=self._conf.use_test_server,\n                use_server=self._conf.use_server,\n            )\n        )\n        if np.metadata.public_key is None:\n            raise MalformedNanopubError(f\"Public key not found in the nanopub {np.source_uri}\")\n        if self._conf.profile.public_key is None:\n            raise ValueError(f\"Public key not found for profile {self._conf.profile.orcid_id}\")\n        if np.metadata.public_key != self._conf.profile.public_key is None:\n            raise AssertionError(\n                \"The public key in your profile does not match the public key\"\n                \"that the publication that you want to retract is signed with.\"\n            )\n</code></pre>"},{"location":"reference/templates/#nanopub.templates.nanopub_index.NanopubIndex","title":"<code>NanopubIndex</code>","text":"<p>             Bases: <code>Nanopub</code></p> <p>Publish a list of nanopub URIs in a Nanopub Index</p> <p>Parameters:</p> Name Type Description Default <code>conf</code> <code>NanopubConf</code> <p>config for the nanopub</p> required <code>np_list</code> <code>Union[List[str], List[Nanopub]]</code> <p>List of nanopub URIs</p> required <code>title</code> <code>str</code> <p>Title of the Nanopub Index</p> required <code>description</code> <code>str</code> <p>Description of the Nanopub Index</p> required <code>creation_time</code> <code>str</code> <p>Creation time of the Nanopub Index, in format YYYY-MM-DDThh-mm-ss</p> required <code>creators</code> <code>List[str]</code> <p>List of the ORCID of the creators of the Nanopub Index</p> required <code>see_also</code> <code>str</code> <p>A URL to a page with further information on the Nanopub Index</p> <code>None</code> Source code in <code>nanopub/templates/nanopub_index.py</code> <pre><code>class NanopubIndex(Nanopub):\n    \"\"\"Publish a list of nanopub URIs in a Nanopub Index\n\n    Args:\n        conf: config for the nanopub\n        np_list: List of nanopub URIs\n        title: Title of the Nanopub Index\n        description: Description of the Nanopub Index\n        creation_time: Creation time of the Nanopub Index, in format YYYY-MM-DDThh-mm-ss\n        creators: List of the ORCID of the creators of the Nanopub Index\n        see_also: A URL to a page with further information on the Nanopub Index\n    \"\"\"\n\n    def __init__(\n        self,\n        conf: NanopubConf,\n        np_list: Union[List[str], List[Nanopub]],\n        title: str,\n        description: str,\n        creation_time: str,\n        creators: List[str],\n        see_also: str = None,\n        top_level: bool = False,\n    ) -&gt; None:\n        conf = deepcopy(conf)\n        conf.add_prov_generated_time = False\n        conf.add_pubinfo_generated_time = True\n        conf.attribute_publication_to_profile = True\n        super().__init__(\n            conf=conf,\n        )\n\n        for np in np_list:\n            if isinstance(np, Nanopub):\n                np_uri = np.source_uri\n            else:\n                np_uri = np\n            if top_level:\n                self.assertion.add((DUMMY_URI, NPX.appendsIndex, URIRef(np_uri)))\n            else:\n                self.assertion.add((DUMMY_URI, NPX.includesElement, URIRef(np_uri)))\n\n        self.pubinfo.add((DUMMY_URI, RDF.type, NPX.NanopubIndex))\n        self.pubinfo.add((DUMMY_URI, DC.title, Literal(title)))\n        self.pubinfo.add((DUMMY_URI, DC.description, Literal(description)))\n        if see_also:\n            self.pubinfo.add((DUMMY_URI, RDFS.seeAlso, URIRef(see_also)))\n        for creator in creators:\n            self.pubinfo.add((DUMMY_URI, PAV.createdBy, URIRef(creator)))\n        # TODO: use current time if not provided\n        # datetime.datetime.now().astimezone().replace(microsecond=0).isoformat() ?\n        self.pubinfo.add(\n            (\n                DUMMY_URI,\n                DCTERMS.created,\n                Literal(creation_time, datatype=XSD.dateTime, normalize=False),\n            )\n        )\n\n        self.provenance.add((DUMMY_NAMESPACE.assertion, RDF.type, NPX.IndexAssertion))\n</code></pre>"},{"location":"reference/templates/#nanopub.templates.nanopub_index.create_nanopub_index","title":"<code>create_nanopub_index(conf, np_list, title, description, creation_time, creators, see_also=None)</code>","text":"<p>Create a Nanopub index.</p> <p>Publish a list of nanopub URIs in a Nanopub Index</p> <p>Parameters:</p> Name Type Description Default <code>np_list</code> <code>Union[List[str], List[Nanopub]]</code> <p>List of nanopub URIs</p> required <code>title</code> <code>str</code> <p>Title of the Nanopub Index</p> required <code>description</code> <code>str</code> <p>Description of the Nanopub Index</p> required <code>creation_time</code> <code>str</code> <p>Creation time of the Nanopub Index, in format YYYY-MM-DDThh-mm-ss</p> required <code>creators</code> <code>List[str]</code> <p>List of the ORCID of the creators of the Nanopub Index</p> required <code>see_also</code> <code>str</code> <p>A URL to a page with further information on the Nanopub Index</p> <code>None</code> Source code in <code>nanopub/templates/nanopub_index.py</code> <pre><code>def create_nanopub_index(\n    conf: NanopubConf,\n    np_list: Union[List[str], List[Nanopub]],\n    title: str,\n    description: str,\n    creation_time: str,\n    creators: List[str],\n    see_also: str = None,\n) -&gt; List[Nanopub]:\n    \"\"\"Create a Nanopub index.\n\n    Publish a list of nanopub URIs in a Nanopub Index\n\n    Args:\n        np_list: List of nanopub URIs\n        title: Title of the Nanopub Index\n        description: Description of the Nanopub Index\n        creation_time: Creation time of the Nanopub Index, in format YYYY-MM-DDThh-mm-ss\n        creators: List of the ORCID of the creators of the Nanopub Index\n        see_also: A URL to a page with further information on the Nanopub Index\n    \"\"\"\n    pub_list: List[Nanopub] = []\n    for i in range(0, len(np_list), MAX_NP_PER_INDEX):\n        np_chunk = np_list[i:i + MAX_NP_PER_INDEX]\n        pub = NanopubIndex(\n            conf,\n            np_chunk,\n            title,\n            description,\n            creation_time,\n            creators,\n            see_also,\n            top_level=False\n        )\n        pub.sign()\n        log.info(f\"Signed Nanopub Index: {pub.source_uri}\")\n        pub_list.append(pub)\n\n    if len(pub_list) &gt; 1:\n        toplevel_pub = NanopubIndex(\n            conf,\n            pub_list,\n            title,\n            description,\n            creation_time,\n            creators,\n            see_also,\n            top_level=True\n        )\n        toplevel_pub.sign()\n        log.info(f\"Signed top level Nanopub Index: {toplevel_pub.source_uri}\")\n        pub_list.append(toplevel_pub)\n\n    return pub_list\n</code></pre>"},{"location":"reference/templates/#nanopub.templates.nanopub_introduction.NanopubIntroduction","title":"<code>NanopubIntroduction</code>","text":"<p>             Bases: <code>Nanopub</code></p> <p>Publish a Nanopub introduction to introduce a key pair for an ORCID</p> <p>Parameters:</p> Name Type Description Default <code>conf</code> <code>NanopubConf</code> <p>config for the nanopub</p> required <code>host</code> <code>Optional[str]</code> <p>the service where the keypair are hosted</p> <code>None</code> Source code in <code>nanopub/templates/nanopub_introduction.py</code> <pre><code>class NanopubIntroduction(Nanopub):\n    \"\"\"Publish a Nanopub introduction to introduce a key pair for an ORCID\n\n    Args:\n        conf: config for the nanopub\n        host: the service where the keypair are hosted\n    \"\"\"\n\n    def __init__(\n        self,\n        conf: NanopubConf,\n        host: Optional[str] = None,\n    ) -&gt; None:\n        conf = deepcopy(conf)\n        conf.add_prov_generated_time = False\n        conf.add_pubinfo_generated_time = True\n        conf.attribute_publication_to_profile = True\n        conf.attribute_assertion_to_profile = True\n        super().__init__(\n            conf=conf,\n        )\n        if not self.profile:\n            raise ProfileError(\"No profile provided, cannot generate a Nanopub Introduction\")\n\n        key_declaration = self._metadata.namespace.keyDeclaration\n        orcid_node = URIRef(self.conf.profile.orcid_id)\n\n        self.assertion.add((key_declaration, NPX.declaredBy, orcid_node))\n        self.assertion.add((key_declaration, NPX.hasAlgorithm, Literal(\"RSA\")))\n        self.assertion.add((key_declaration, NPX.hasPublicKey, Literal(self.conf.profile.public_key)))\n        self.assertion.add((orcid_node, FOAF.name, Literal(self.conf.profile.name)))\n        if host:\n            self.assertion.add((key_declaration, NPX.hasKeyLocation, URIRef(host)))\n</code></pre>"},{"location":"searching/fetching/","title":"Fetching nanopublications","text":""},{"location":"searching/fetching/#fetch-from-the-default-server","title":"Fetch from the default server","text":"<p>You can fetch nanopublications from the default nanopub server using the <code>Nanopub</code> class.</p> <pre><code>from nanopub import Nanopub\n\n# Fetch the nanopublication at the specified URI\nnp = Nanopub('http://purl.org/np/RApJG4fwj0szOMBMiYGmYvd5MCtRle6VbwkMJUb1SxxDM')\n\n# Print the RDF contents of the nanopublication\nprint(np)\n\n# Iterate through all triples in the assertion graph\nfor s, p, o in np.assertion:\n    print(s, p, o)\n\n# Iterate through the publication info\nfor s, p, o in np.pubinfo:\n    print(s, p, o)\n\n# Iterate through the provenance graph\nfor s, p, o in np.provenance:\n    print(s,p,o)\n\n# See the concept that is introduced by this nanopublication (if any)\nprint(np.introduces_concept)\n</code></pre>"},{"location":"searching/fetching/#fetch-from-a-specific-server","title":"Fetch from a specific server","text":"<p>You can fetch Nanopubs from the test server:</p> <pre><code>from nanopub import Nanopub\n\nnp = Nanopub(\n    source_uri='http://purl.org/np/RANGY8fx_EYVeZzJOinH9FoY-WrQBerKKUy2J9RCDWH6U',\n    conf=NanopubConf(use_test_server=True)\n)\nprint(np)\n</code></pre> <p>Or from a specific nanopub server:</p> <pre><code>np = Nanopub(\n    source_uri='http://purl.org/np/RApJG4fwj0szOMBMiYGmYvd5MCtRle6VbwkMJUb1SxxDM',\n    conf=NanopubConf(use_server='https://np.petapico.org')\n)\nprint(np)\n</code></pre>"},{"location":"searching/searching/","title":"Searching the nanopub server","text":"<p>The <code>NanopubClient</code> provides methods for searching the nanopub server. It provides an (incomplete) mapping to the nanopub server grlc endpoint.</p>"},{"location":"searching/searching/#text-search","title":"Text search","text":"<p>Search for all nanopublications containing some text using <code>NanopubClient.find_nanopubs_with_text()</code> <pre><code>from nanopub import NanopubClient\n\nclient = NanopubClient()\nresults = client.find_nanopubs_with_text('fair')\n</code></pre></p>"},{"location":"searching/searching/#triple-pattern-search","title":"Triple pattern search","text":"<p>Search for nanopublications whose assertions contain triples that match a specific pattern. <pre><code>from nanopub import NanopubClient\n\nclient = NanopubClient()\n# Search for nanopublications whose assertions contain triples that are ```rdf:Statement```s.\nresults = client.find_nanopubs_with_pattern(\n    pred='http://www.w3.org/1999/02/22-rdf-syntax-ns#type',\n    obj='http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement'\n)\n</code></pre></p>"},{"location":"searching/searching/#search-on-introduced-concept","title":"Search on introduced concept","text":"<p>Search for any nanopublications that introduce a concept of the given type, that contain text with the given search term. <pre><code>from nanopub import NanopubClient\n\nclient = NanopubClient()\n# Search for nanopublications that introduce a concept that is a ```p-plan:Step```.\nresults = client.find_things('http://purl.org/net/p-plan#Step')\n</code></pre></p>"},{"location":"searching/searching/#interpreting-search-results","title":"Interpreting search results","text":"<p>Each search method returns a generator of dicts depicting matching nanopublications.</p> <p>Each dict has the following key-value pairs: * <code>date</code>: The date and time the nanopublication was created. * <code>description</code>: A description of the nanopublication that was parsed from the nanopublication RDF. * <code>np</code>: The URI of the matching nanopublication.</p> <p>Example results (from <code>NanopubClient.find_nanopubs_with_text('fair')</code>): <pre><code>print(list(results))\n[{'date': '2020-05-01T08:05:25.575Z',\n  'description': 'The primary objective of the VODAN Implementation Network is '\n                 'to showcase the creation and deployment of FAIR data related '\n                 'to COVID-19',\n  'np': 'http://purl.org/np/RAdDKjIGPt_2mE9oJtB3YQX6wGGdCC8ZWpkxEIoHsxOjE'},\n {'date': '2020-05-14T09:34:53.554Z',\n  'description': 'FAIR IN community',\n  'np': 'http://purl.org/np/RAPE0A-NrIZDeX3pvFJr0uHshocfXuUj8n_J3BkY0sMuU'}]\n</code></pre></p>"},{"location":"searching/searching/#returning-retracted-publications-in-search","title":"Returning retracted publications in search","text":"<p>By default nanopublications that have a valid retraction do not show up in search results. A valid retraction is a retraction that is signed with the same public key as the nanopublication that it retracts.</p> <p>You can toggle this behavior with the <code>filter_retracted</code> parameter, here is an example with <code>NanopubClient.find_nanopubs_with_text</code>:</p> <pre><code>from nanopub import NanopubClient\n\nclient = NanopubClient()\n# Search for nanopublications containing the text fair, also returning retracted publications.\nresults = client.find_nanopubs_with_text('fair', filter_retracted=False)\n</code></pre>"},{"location":"searching/searching/#filtering-search-results-for-a-particular-publication-key","title":"Filtering search results for a particular publication key","text":"<p>You can filter search results to publications that are signed with a specific publication key (effectively filtering on publications from a single author).</p> <p>You use the <code>pubkey</code> argument for that. Here is an example with <code>NanopubClient.find_nanopubs_with_text</code>:</p> <pre><code>from nanopub import NanopubClient, profile\n\n# Search for nanopublications containing the text 'test',\n# filtering on publications signed with my publication key.\nclient = NanopubClient(use_test_server=True)\nmy_public_key = profile.public_key\nresults = client.find_nanopubs_with_text('test', pubkey=my_public_key)\n</code></pre>"}]}